{"version":3,"names":["TextEditor","constructor","column","saveCallback","this","element","editCell","componentDidRender","editInput","timeout","_a","focus","onKeyDown","e","isEnter","isEnterKey","code","isKeyTab","isTab","target","isComposing","blur","getValue","value","render","h","type","val","ref","el","revogrEditStyleCss","RevoEdit","currentEditor","saveRunning","cancel","onAutoSave","beforeAutoSave","canSave","onSave","preventFocus","cellEdit","emit","rgCol","x","rgRow","y","prop","componentWillRender","editor","focusNext","closeEdit","firstElementChild","_b","call","disconnectedCallback","saveOnClose","Host","class","EDIT_INPUT_WR","additionalData","RowOrderService","config","currentCell","previousRow","endOrder","data","newRow","getCell","positionChanged","clear","startOrder","move","getRow","itemIndex","rows","top","getBoundingClientRect","topRelative","getItemByPosition","absolutePosition","start","end","cols","left","leftRelative","OrderEditor","rowMoveFunc","debounce","rowOrderService","getData","internalRowDrag","onMouseOut","clearOrder","onMouseUp","dragStart","originalEvent","preventDefault","moveFunc","cell","pos","dragStartEvent","internalRowDragStart","text","DRAGG_TEXT","event","defaultPrevented","document","addEventListener","removeEventListener","internalRowDragEnd","internalRowMouseMove","connectedCallback","f","t","onPositionChanged","from","to","dropEvent","initialRowDropped","items","dataStore","get","toMove","splice","setItems","parent","dimensionRow","state","dimensionCol"],"sources":["src/components/overlay/editors/text.tsx","src/components/overlay/revogr-edit-style.scss?tag=revogr-edit","src/components/overlay/revogr-edit.tsx","src/components/order/rowOrderService.ts","src/components/order/revogr-order-editor.tsx"],"sourcesContent":["import { h } from '@stencil/core';\nimport { isEnterKey, isTab } from '../../../utils/keyCodes.utils';\nimport { Edition, RevoGrid } from '../../../interfaces';\nimport { timeout } from '../../../utils';\n\n/**\n * Callback triggered on cell editor save\n * Closes editor when called\n * @param preventFocus - if true editor will not be closed and next cell will not be focused\n */\nexport type SaveCallback = (value: Edition.SaveData, preventFocus: boolean) => void;\n\nexport class TextEditor implements Edition.EditorBase {\n  private editInput!: HTMLInputElement;\n\n  public element: Element | null = null;\n  public editCell: Edition.EditCell | null = null;\n\n  constructor(public column: RevoGrid.ColumnRegular, private saveCallback?: SaveCallback) {}\n\n  async componentDidRender(): Promise<void> {\n    if (this.editInput) {\n      await timeout();\n      this.editInput?.focus();\n    }\n  }\n\n  private onKeyDown(e: KeyboardEvent): void {\n    const isEnter = isEnterKey(e.code);\n    const isKeyTab = isTab(e.code);\n\n    if ((isKeyTab || isEnter) && e.target && this.saveCallback && !e.isComposing) {\n      // blur is needed to avoid autoscroll\n      this.editInput.blur();\n      // request callback which will close cell after all\n      this.saveCallback(this.getValue(), isKeyTab);\n    }\n  }\n  \n  getValue() {\n    return this.editInput?.value;\n  }\n\n  // required\n  render() {\n    return (\n      <input\n        type=\"text\"\n        value={this.editCell?.val || ''}\n        ref={el => {\n          this.editInput = el;\n        }}\n        onKeyDown={e => this.onKeyDown(e)}\n      />\n    );\n  }\n}\n","revogr-edit {\n  display: block;\n  position: absolute;\n  background-color: #fff;\n\n  input {\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n  }\n\n  revo-dropdown {\n    height: 100%;\n\n    &.shrink {\n      fieldset legend > span {\n        display: none;\n      }\n    }\n  }\n}\n","import { Component, Event, EventEmitter, Prop, h, Element, Host, Method } from '@stencil/core';\n\nimport { Edition, RevoGrid } from '../../interfaces';\nimport { EDIT_INPUT_WR } from '../../utils/consts';\nimport { TextEditor } from './editors/text';\n\n/**\n * Cell editor component\n */\n@Component({\n  tag: 'revogr-edit',\n  styleUrl: 'revogr-edit-style.scss',\n})\nexport class RevoEdit {\n  @Element() element: HTMLElement;\n  @Prop() editCell: Edition.EditCell;\n\n  @Prop() column: RevoGrid.ColumnRegular | null;\n  /** Custom editors register */\n  @Prop() editor: Edition.EditorCtr | null;\n\n  /** Save on editor close */\n  @Prop() saveOnClose: boolean = false;\n  /** Additional data to pass to renderer */\n  @Prop() additionalData: any;\n\n  /** Cell edit event */\n  @Event() cellEdit: EventEmitter<Edition.SaveDataDetails>;\n\n  /**\n   * Close editor event\n   * pass true if requires focus next\n   */\n  @Event() closeEdit: EventEmitter<boolean | undefined>;\n\n  /** Edit session editor */\n  private currentEditor: Edition.EditorBase | null = null;\n  private saveRunning = false;\n\n  @Method() async cancel() {\n    this.saveRunning = true;\n  }\n\n  onAutoSave() {\n    this.saveRunning = true;\n    const val = this.currentEditor.getValue && this.currentEditor.getValue();\n    // for editor plugin internal usage in case you want to stop save and use your own\n    if (this.currentEditor.beforeAutoSave) {\n      const canSave = this.currentEditor.beforeAutoSave(val);\n      if (canSave === false) {\n        return;\n      }\n    }\n    this.onSave(val, true);\n  }\n\n  /**\n   * Callback triggered on cell editor save\n   * Closes editor when called\n   * @param preventFocus - if true editor will not be closed and next cell will not be focused\n   */\n  onSave(val: Edition.SaveData, preventFocus?: boolean): void {\n    this.saveRunning = true;\n    if (this.editCell) {\n      this.cellEdit.emit({\n        rgCol: this.editCell.x,\n        rgRow: this.editCell.y,\n        type: this.editCell.type,\n        prop: this.editCell.prop,\n        val,\n        preventFocus,\n      });\n    }\n  }\n\n  componentWillRender(): void {\n    // we have active editor\n    if (this.currentEditor) {\n      return;\n    }\n    this.saveRunning = false;\n    \n    // custom editor usage\n    // use TextEditor (editors/text.tsx) to create custom editor\n    if (this.editor) {\n      this.currentEditor = new this.editor(\n        this.column,\n        // save\n        (e, preventFocus) => {\n          this.onSave(e, preventFocus);\n        },\n        // cancel\n        focusNext => {\n          this.saveRunning = true;\n          this.closeEdit.emit(focusNext);\n        },\n      );\n      return;\n    }\n    // default text editor usage\n    this.currentEditor = new TextEditor(this.column, (e, preventFocus) => this.onSave(e, preventFocus));\n  }\n\n  componentDidRender(): void {\n    if (!this.currentEditor) {\n      return;\n    }\n    this.currentEditor.element = this.element.firstElementChild;\n    this.currentEditor.componentDidRender?.();\n  }\n\n  disconnectedCallback(): void {\n    if (this.saveOnClose) {\n      // shouldn't be cancelled by saveRunning\n      // editor requires getValue to be able to save\n      if (!this.saveRunning) {\n        this.onAutoSave();\n      }\n    }\n\n    this.saveRunning = false;\n    if (!this.currentEditor) {\n      return;\n    }\n\n    this.currentEditor.disconnectedCallback && this.currentEditor.disconnectedCallback();\n    if (this.currentEditor.element) {\n      this.currentEditor.element = null;\n    }\n    this.currentEditor = null;\n  }\n\n  render() {\n    if (this.currentEditor) {\n      this.currentEditor.editCell = this.editCell;\n      return <Host class={EDIT_INPUT_WR}>{this.currentEditor.render(h, this.additionalData)}</Host>;\n    }\n    return '';\n  }\n}\n","import { RevoGrid, Selection } from '../../interfaces';\nimport { getItemByPosition } from '../../store/dimension/dimension.helpers';\n\ntype EventData = { el: HTMLElement; rows: RevoGrid.DimensionSettingsState; cols: RevoGrid.DimensionSettingsState };\ninterface Config {\n  positionChanged(from: number, to: number): void;\n}\n\nexport default class RowOrderService {\n  private currentCell: Selection.Cell | null = null;\n  private previousRow: number | null = null;\n\n  constructor(private config: Config) {}\n\n  /** Drag finished, calculate and apply changes */\n  endOrder(e: MouseEvent, data: EventData): void {\n    if (this.currentCell === null) {\n      return;\n    }\n    const newRow = this.getCell(e, data);\n\n    // if position changed\n    if (newRow.y !== this.currentCell.y) {\n      // rgRow dragged out table\n      if (newRow.y < 0) {\n        newRow.y = 0;\n      }\n      // rgRow dragged to the top\n      else if (newRow.y < this.currentCell.y) {\n        newRow.y++;\n      }\n      this.config.positionChanged(this.currentCell.y, newRow.y);\n    }\n    this.clear();\n  }\n\n  /** Drag started, reserve initial cell for farther use */\n  startOrder(e: MouseEvent, data: EventData): Selection.Cell {\n    this.currentCell = this.getCell(e, data);\n    return this.currentCell;\n  }\n\n  move(y: number, data: EventData): RevoGrid.PositionItem | null {\n    const rgRow = this.getRow(y, data);\n    // if rgRow same as previous or below range (-1 = 0) do nothing\n    if (this.previousRow === rgRow.itemIndex || rgRow.itemIndex < -1) {\n      return null;\n    }\n    this.previousRow = rgRow.itemIndex;\n    return rgRow;\n  }\n\n  /** Drag stopped, probably cursor outside of document area */\n  clear(): void {\n    this.currentCell = null;\n    this.previousRow = null;\n  }\n\n  /** Calculate cell based on x, y position */\n  getRow(y: number, { el, rows }: EventData): RevoGrid.PositionItem {\n    const { top } = el.getBoundingClientRect();\n    const topRelative = y - top;\n    const rgRow = getItemByPosition(rows, topRelative);\n    const absolutePosition = {\n      itemIndex: rgRow.itemIndex,\n      start: rgRow.start + top,\n      end: rgRow.end + top,\n    };\n    return absolutePosition;\n  }\n\n  /** Calculate cell based on x, y position */\n  getCell({ x, y }: Selection.Cell, { el, rows, cols }: EventData): Selection.Cell {\n    const { top, left } = el.getBoundingClientRect();\n    const topRelative = y - top;\n    const leftRelative = x - left;\n    const rgRow = getItemByPosition(rows, topRelative);\n    const rgCol = getItemByPosition(cols, leftRelative);\n    return { x: rgCol.itemIndex, y: rgRow.itemIndex };\n  }\n}\n","import { Component, Method, Event, EventEmitter, Prop, Listen } from '@stencil/core';\nimport debounce from 'lodash/debounce';\n\nimport { DragStartEvent, Observable, RevoGrid, Selection } from '../../interfaces';\nimport { DataSourceState, setItems } from '../../store/dataSource/data.store';\nimport { DRAGG_TEXT } from '../../utils/consts';\nimport RowOrderService from './rowOrderService';\n\n@Component({ tag: 'revogr-order-editor' })\nexport class OrderEditor {\n  private rowOrderService: RowOrderService;\n  private moveFunc: ((e: Selection.Cell) => void) | null;\n  private rowMoveFunc = debounce((y: number) => {\n    const rgRow = this.rowOrderService.move(y, this.getData());\n    if (rgRow !== null) {\n      this.internalRowDrag.emit(rgRow);\n    }\n  }, 5);\n\n  // --------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  // --------------------------------------------------------------------------\n  @Prop() parent: HTMLElement;\n  @Prop() dimensionRow: Observable<RevoGrid.DimensionSettingsState>;\n  @Prop() dimensionCol: Observable<RevoGrid.DimensionSettingsState>;\n\n  /** Static stores, not expected to change during component lifetime */\n  @Prop() dataStore: Observable<DataSourceState<RevoGrid.DataType, RevoGrid.DimensionRows>>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Events\n  //\n  // --------------------------------------------------------------------------\n\n  /** Row drag started */\n  @Event({ cancelable: true }) internalRowDragStart: EventEmitter<{\n    cell: Selection.Cell;\n    text: string;\n    pos: RevoGrid.PositionItem;\n    event: MouseEvent;\n  }>;\n\n  /** Row drag ended */\n  @Event({ cancelable: true }) internalRowDragEnd: EventEmitter;\n\n  /** Row move */\n  @Event({ cancelable: true }) internalRowDrag: EventEmitter<RevoGrid.PositionItem>;\n\n  /** Row mouse move */\n  @Event({ cancelable: true }) internalRowMouseMove: EventEmitter<Selection.Cell>;\n\n  /** Row dragged, new range ready to be applied */\n  @Event({ cancelable: true }) initialRowDropped: EventEmitter<{ from: number; to: number }>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Listeners\n  //\n  // --------------------------------------------------------------------------\n\n  @Listen('mouseleave', { target: 'document' })\n  onMouseOut(): void {\n    this.clearOrder();\n  }\n\n  /** Action finished inside of the document */\n  @Listen('mouseup', { target: 'document' })\n  onMouseUp(e: MouseEvent): void {\n    this.endOrder(e);\n  }\n\n  // --------------------------------------------------------------------------\n  //\n  //  Methods\n  //\n  // --------------------------------------------------------------------------\n\n  @Method() async dragStart(e: DragStartEvent) {\n    e.originalEvent.preventDefault();\n\n    // extra check if previous ended\n    if (this.moveFunc) {\n      this.clearOrder();\n    }\n\n    const data = this.getData();\n    const cell = this.rowOrderService.startOrder(e.originalEvent, data);\n    const pos = this.rowOrderService.getRow(e.originalEvent.y, data);\n    const dragStartEvent = this.internalRowDragStart.emit({ cell, text: DRAGG_TEXT, pos, event: e.originalEvent });\n    if (dragStartEvent.defaultPrevented) {\n      return;\n    }\n\n    this.moveFunc = (e: MouseEvent) => this.move(e);\n    document.addEventListener('mousemove', this.moveFunc);\n  }\n\n  @Method() async endOrder(e: MouseEvent) {\n    this.rowOrderService.endOrder(e, this.getData());\n    this.clearOrder();\n  }\n\n  @Method() async clearOrder() {\n    this.rowOrderService.clear();\n    document.removeEventListener('mousemove', this.moveFunc);\n    this.moveFunc = null;\n    this.internalRowDragEnd.emit();\n  }\n\n  // --------------------------------------------------------------------------\n  //\n  //  Component methods\n  //\n  // --------------------------------------------------------------------------\n\n  move({ x, y }: { x: number; y: number }): void {\n    this.internalRowMouseMove.emit({ x, y });\n    this.rowMoveFunc(y);\n  }\n\n  connectedCallback(): void {\n    this.rowOrderService = new RowOrderService({ positionChanged: (f, t) => this.onPositionChanged(f, t) });\n  }\n\n  private onPositionChanged(from: number, to: number) {\n    const dropEvent = this.initialRowDropped.emit({ from, to });\n    if (dropEvent.defaultPrevented) {\n      return;\n    }\n    const items = [...this.dataStore.get('items')];\n    const toMove = items.splice(from, 1);\n    items.splice(to, 0, ...toMove);\n    setItems(this.dataStore, items);\n  }\n\n  private getData() {\n    return {\n      el: this.parent,\n      rows: this.dimensionRow.state,\n      cols: this.dimensionCol.state,\n    };\n  }\n}\n"],"mappings":"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"}