{"version":3,"names":["ColumnService","columns","getVisibleSourceItem","this","source","constructor","dataStore","unsubscribe","hasGrouping","push","onChange","s","checkGrouping","get","type","cols","rgCol","isGroupingColumn","isReadOnly","r","c","readOnly","_a","readonly","data","rowDataModel","doMerge","existing","extra","props","Object","assign","class","style","mergeProperties","defaultProps","cellClass","CELL_CLASS","DISABLED_CLASS","extraPropsFunc","cellProperties","getRowClass","prop","model","getSourceItem","getCellData","getData","getSaveData","rowIndex","colIndex","val","colType","getCellEditor","_r","editors","editor","undefined","column","getRangeData","d","changed","copyColLength","oldRange","x1","x","copyRowLength","y1","y","mapping","newRange","i","oldRowIndex","copyRow","j","copyColIndex","copyColumnProp","colProp","getTransformedDataToApply","start","length","colLength","rowLength","maxCol","p","currentCol","Math","max","range","getRange","applyRangeData","items","oldModel","parseInt","setSourceByVirtualIndex","getRangeStaticData","value","getRangeTransformedToProps","store","area","copyRangeArray","slice","map","v","toCopy","rgRow","item","destroy","forEach","f","initialParams","contentSize","clientSize","virtualSize","maxSize","NO_COORDINATE","LocalScrollService","cfg","preventArtificialScroll","previousScroll","params","getVirtualContentSize","setParams","dimension","virtualContentSize","setScroll","e","cancelScroll","frameAnimation","Promise","resolve","reject","skipAnimationFrame","animationId","window","requestAnimationFrame","bind","getParams","coordinate","ceil","wrapCoordinate","afterScroll","convert","id","cancelAnimationFrame","scroll","force","delta","outside","param","beforeScroll","canceler","pos","toReal","minRange","from","to","scaleValue"],"sources":["src/components/data/columnService.ts","src/services/localScrollService.ts"],"sourcesContent":["import { DataSourceState, getSourceItem, getVisibleSourceItem, setSourceByVirtualIndex } from '../../store/dataSource/data.store';\nimport { CELL_CLASS, DISABLED_CLASS } from '../../utils/consts';\nimport { Edition, Observable, RevoGrid, Selection } from '../../interfaces';\nimport { getRange } from '../../store/selection/selection.helpers';\n\nimport { isGroupingColumn } from '../../plugins/groupingRow/grouping.service';\nimport { slice } from 'lodash';\n\nexport type ColumnSource<T = RevoGrid.ColumnRegular> = Observable<DataSourceState<T, RevoGrid.DimensionCols>>;\nexport type RowSource = Observable<DataSourceState<RevoGrid.DataType, RevoGrid.DimensionRows>>;\n\nexport type ColumnStores = {\n  [T in RevoGrid.DimensionCols]: ColumnSource;\n};\nexport type RowStores = {\n  [T in RevoGrid.DimensionRows]: RowSource;\n};\n\nexport default class ColumnService {\n  private unsubscribe: { (): void }[] = [];\n  get columns(): RevoGrid.ColumnRegular[] {\n    return getVisibleSourceItem(this.source);\n  }\n\n  hasGrouping = false;\n  type: RevoGrid.DimensionCols;\n\n  constructor(private dataStore: RowSource, private source: ColumnSource) {\n    this.unsubscribe.push(source.onChange('source', s => this.checkGrouping(s)));\n    this.checkGrouping(source.get('source'));\n    this.type = source.get('type');\n  }\n\n  private checkGrouping(cols: RevoGrid.ColumnRegular[]) {\n    for (let rgCol of cols) {\n      if (isGroupingColumn(rgCol)) {\n        this.hasGrouping = true;\n        return;\n      }\n      this.hasGrouping = false;\n    }\n  }\n\n  isReadOnly(r: number, c: number): boolean {\n    const readOnly: RevoGrid.ReadOnlyFormat = this.columns[c]?.readonly;\n    if (typeof readOnly === 'function') {\n      const data = this.rowDataModel(r, c);\n      return readOnly(data);\n    }\n    return readOnly;\n  }\n\n  static doMerge(existing: RevoGrid.CellProps, extra: RevoGrid.CellProps) {\n    let props: RevoGrid.CellProps = { ...extra, ...existing };\n    // extend existing props\n    if (extra.class) {\n      if (typeof extra.class === 'object' && typeof props.class === 'object') {\n        props.class = { ...extra.class, ...props.class };\n      } else if (typeof extra.class === 'string' && typeof props.class === 'object') {\n        props.class[extra.class] = true;\n      } else if (typeof props.class === 'string') {\n        props.class += ' ' + extra.class;\n      }\n    }\n    if (extra.style) {\n      props.style = { ...extra.style, ...props.style };\n    }\n    return props;\n  }\n\n  mergeProperties(r: number, c: number, defaultProps: RevoGrid.CellProps): RevoGrid.CellProps {\n    const cellClass: { [key: string]: boolean } = {\n      [CELL_CLASS]: true,\n      [DISABLED_CLASS]: this.isReadOnly(r, c),\n    };\n    let props: RevoGrid.CellProps = {\n      ...defaultProps,\n      class: cellClass,\n    };\n    const extraPropsFunc = this.columns[c]?.cellProperties;\n    if (extraPropsFunc) {\n      const data = this.rowDataModel(r, c);\n      const extra = extraPropsFunc(data);\n      if (!extra) {\n        return props;\n      }\n      return ColumnService.doMerge(props, extra);\n    }\n    return props;\n  }\n\n  getRowClass(r: number, prop: string): string {\n    const model = getSourceItem(this.dataStore, r) || {};\n    return model[prop] || '';\n  }\n\n  getCellData(r: number, c: number): string {\n    const data = this.rowDataModel(r, c);\n    return ColumnService.getData(data.model[data.prop as number]);\n  }\n\n  getSaveData(rowIndex: number, colIndex: number, val?: string): Edition.BeforeSaveDataDetails {\n    if (typeof val === 'undefined') {\n      val = this.getCellData(rowIndex, colIndex);\n    }\n    const data = this.rowDataModel(rowIndex, colIndex);\n    return {\n      prop: data.prop,\n      rowIndex,\n      colIndex,\n      val,\n      model: data.model,\n      colType: this.type,\n      type: this.dataStore.get('type'),\n    };\n  }\n\n  getCellEditor(_r: number, c: number, editors: Edition.Editors): Edition.EditorCtr | undefined {\n    const editor = this.columns[c]?.editor;\n    if (!editor) {\n      return undefined;\n    }\n    // reference\n    if (typeof editor === 'string') {\n      return editors[editor];\n    }\n    return editor;\n  }\n\n  rowDataModel(rowIndex: number, colIndex: number): RevoGrid.ColumnDataSchemaModel {\n    const column = this.columns[colIndex];\n    const prop: RevoGrid.ColumnProp | undefined = column?.prop;\n    const model = getSourceItem(this.dataStore, rowIndex) || {};\n    const type = this.dataStore.get('type');\n    return {\n      prop,\n      model,\n      data: this.dataStore.get('source'),\n      column,\n      rowIndex,\n      colIndex,\n      colType: this.type,\n      type,\n    };\n  }\n\n  getRangeData(d: Selection.ChangedRange, columns: RevoGrid.ColumnRegular[]): {\n    changed: RevoGrid.DataLookup,\n    mapping: Selection.OldNewRangeMapping,\n  } {\n    const changed: RevoGrid.DataLookup = {};\n\n    // get original length sizes\n    const copyColLength = d.oldRange.x1 - d.oldRange.x + 1;\n    const copyRowLength = d.oldRange.y1 - d.oldRange.y + 1;\n    const mapping: Selection.OldNewRangeMapping = {};\n\n    // rows\n    for (let rowIndex = d.newRange.y, i = 0; rowIndex < d.newRange.y1 + 1; rowIndex++, i++) {\n      // copy original data link\n      const oldRowIndex = d.oldRange.y + i % copyRowLength;\n      const copyRow = getSourceItem(this.dataStore, oldRowIndex) || {};\n\n      // columns\n      for (let colIndex = d.newRange.x, j = 0; colIndex < d.newRange.x1 + 1; colIndex++, j++) {\n        // check if old range area\n        if (rowIndex >= d.oldRange.y && rowIndex <= d.oldRange.y1 && colIndex >= d.oldRange.x && colIndex <= d.oldRange.x1) {\n          continue;\n        }\n\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const prop = this.columns[colIndex]?.prop;\n        const copyColIndex = d.oldRange.x + j % copyColLength;\n        const copyColumnProp = columns[copyColIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][prop] = copyRow[copyColumnProp];\n          /** Generate mapping object */\n          if (!mapping[rowIndex]) {\n            mapping[rowIndex] = {};\n          }\n          mapping[rowIndex][prop] = {\n            colIndex: copyColIndex,\n            colProp: copyColumnProp,\n            rowIndex: oldRowIndex\n          };\n        }\n      }\n    }\n    return {\n      changed,\n      mapping,\n    };\n  }\n\n  getTransformedDataToApply(\n    start: Selection.Cell,\n    data: RevoGrid.DataFormat[][],\n  ): {\n    changed: RevoGrid.DataLookup;\n    range: Selection.RangeArea;\n  } {\n    const changed: RevoGrid.DataLookup = {};\n    const copyRowLength = data.length;\n    const colLength = this.columns.length;\n    const rowLength = this.dataStore.get('items').length;\n    // rows\n    let rowIndex = start.y;\n    let maxCol = 0;\n    for (let i = 0; rowIndex < rowLength && i < copyRowLength; rowIndex++, i++) {\n      // copy original data link\n      const copyRow = data[i % copyRowLength];\n      const copyColLength = copyRow?.length || 0;\n      // columns\n      let colIndex = start.x;\n      for (let j = 0; colIndex < colLength && j < copyColLength; colIndex++, j++) {\n        const p = this.columns[colIndex].prop;\n        const currentCol = j % colLength;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = copyRow[currentCol];\n        }\n      }\n      maxCol = Math.max(maxCol, colIndex - 1);\n    }\n    const range = getRange(start, {\n      y: rowIndex - 1,\n      x: maxCol,\n    });\n    return {\n      changed,\n      range,\n    };\n  }\n\n  applyRangeData(data: RevoGrid.DataLookup) {\n    const items: Record<number, RevoGrid.DataType> = {};\n    for (let rowIndex in data) {\n      const oldModel = (items[rowIndex] = getSourceItem(this.dataStore, parseInt(rowIndex, 10)));\n      if (!oldModel) {\n        continue;\n      }\n      for (let prop in data[rowIndex]) {\n        oldModel[prop] = data[rowIndex][prop];\n      }\n    }\n    setSourceByVirtualIndex(this.dataStore, items);\n  }\n\n  getRangeStaticData(d: Selection.RangeArea, value: RevoGrid.DataFormat): RevoGrid.DataLookup {\n    const changed: RevoGrid.DataLookup = {};\n\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const p = this.columns[colIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = value;\n        }\n      }\n    }\n    return changed;\n  }\n\n  getRangeTransformedToProps(\n    d: Selection.RangeArea,\n    store: Observable<DataSourceState<RevoGrid.DataType, RevoGrid.DimensionRows>>,\n  ) {\n    const area: {\n      prop: RevoGrid.ColumnProp,\n      rowIndex: number,\n      colIndex: number,\n      model: RevoGrid.DataSource,\n      colType: RevoGrid.DimensionCols,\n      type: RevoGrid.DimensionRows,\n    }[] = [];\n\n    const type = this.dataStore.get('type');\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        const prop = this.columns[colIndex]?.prop;\n        area.push({\n          prop,\n          rowIndex,\n          colIndex,\n          model: getSourceItem(store, rowIndex),\n          type,\n          colType: this.type,\n        });\n      }\n    }\n    return area;\n  }\n\n  copyRangeArray(\n    range: Selection.RangeArea,\n    store: Observable<DataSourceState<RevoGrid.DataType, RevoGrid.DimensionRows>>,\n  ) {\n    const cols = [...this.columns];\n    const props = slice(cols, range.x, range.x1 + 1).map(v => v.prop);\n    const toCopy: RevoGrid.DataFormat[][] = [];\n    const mapping: { [rowIndex: number]: { [colProp: RevoGrid.ColumnProp]: any } } = {};\n\n    // rows indexes\n    for (let i = range.y; i <= range.y1; i++) {\n      const rgRow: RevoGrid.DataFormat[] = [];\n      mapping[i] = {};\n\n      // columns indexes\n      for (let prop of props) {\n        const item = getSourceItem(store, i);\n\n        // if no item - skip\n        if (!item) {\n          continue;\n        }\n        const val = item[prop];\n        rgRow.push(val);\n        mapping[i][prop] = val;\n      }\n\n      toCopy.push(rgRow);\n    }\n    return {\n      data: toCopy,\n      mapping\n    };\n  }\n\n  static getData(val?: any) {\n    if (typeof val === 'undefined' || val === null) {\n      return '';\n    }\n    return val;\n  }\n\n  destroy() {\n    this.unsubscribe.forEach(f => f());\n  }\n}\n","import { scaleValue } from '../utils';\nimport { RevoGrid } from '../interfaces';\n\ninterface Config {\n  skipAnimationFrame?: boolean;\n  beforeScroll(e: RevoGrid.ViewPortScrollEvent): void;\n  afterScroll(e: RevoGrid.ViewPortScrollEvent): void;\n}\n\ntype Params = {\n  contentSize: number;\n  virtualContentSize?: number;\n  clientSize: number;\n  virtualSize: number;\n  maxSize?: number;\n};\n\nconst initialParams: Params = {\n  contentSize: 0,\n  clientSize: 0,\n  virtualSize: 0,\n  maxSize: 0,\n};\nconst NO_COORDINATE = -1;\nexport default class LocalScrollService {\n  private preventArtificialScroll: Record<RevoGrid.DimensionType, () => void | null> = { rgRow: null, rgCol: null };\n  // to check if scroll changed\n  private previousScroll: Record<RevoGrid.DimensionType, number> = { rgRow: NO_COORDINATE, rgCol: NO_COORDINATE };\n  private params: Record<RevoGrid.DimensionType, Params> = { rgRow: { ...initialParams }, rgCol: { ...initialParams } };\n\n  constructor(private cfg: Config) {}\n\n  static getVirtualContentSize(contentSize: number, clientSize: number, virtualSize: number = 0): number {\n    return contentSize + (virtualSize ? clientSize - virtualSize : 0);\n  }\n\n  setParams(params: Params, dimension: RevoGrid.DimensionType) {\n    const virtualContentSize = LocalScrollService.getVirtualContentSize(params.contentSize, params.clientSize, params.virtualSize);\n    this.params[dimension] = {\n      ...params,\n      maxSize: virtualContentSize - params.clientSize,\n      virtualContentSize,\n    };\n  }\n\n  // apply scroll values after scroll done\n  async setScroll(e: RevoGrid.ViewPortScrollEvent) {\n    this.cancelScroll(e.dimension);\n\n    const frameAnimation = new Promise<void>((resolve, reject) => {\n      // for example safari desktop has issues with animation frame\n      if (this.cfg.skipAnimationFrame) {\n        return resolve();\n      }\n      const animationId = window.requestAnimationFrame(() => {\n        resolve();\n      });\n      this.preventArtificialScroll[e.dimension] = reject.bind(null, animationId);\n    });\n    try {\n      await frameAnimation;\n      const params = this.getParams(e.dimension);\n      e.coordinate = Math.ceil(e.coordinate);\n      this.previousScroll[e.dimension] = this.wrapCoordinate(e.coordinate, params);\n      this.preventArtificialScroll[e.dimension] = null;\n      this.cfg.afterScroll({\n        ...e,\n        coordinate: params.virtualSize ? this.convert(e.coordinate, params, false) : e.coordinate,\n      });\n\n    } catch (id) {\n      window.cancelAnimationFrame(id);\n    }\n  }\n\n  // initiate scrolling event\n  scroll(\n    coordinate: number,\n    dimension: RevoGrid.DimensionType,\n    force = false,\n    delta?: number,\n    outside = false\n  ) {\n    this.cancelScroll(dimension);\n    if (!force && this.previousScroll[dimension] === coordinate) {\n      this.previousScroll[dimension] = NO_COORDINATE;\n      return;\n    }\n\n    const param = this.getParams(dimension);\n    this.cfg.beforeScroll({\n      dimension: dimension,\n      coordinate: param.virtualSize ? this.convert(coordinate, param) : coordinate,\n      delta,\n      outside\n    });\n  }\n\n  private getParams(dimension: RevoGrid.DimensionType): Params {\n    return this.params[dimension];\n  }\n\n  // check if scroll outside of region to avoid looping\n  private wrapCoordinate(c: number, param: Params): number {\n    if (c < 0) {\n      return NO_COORDINATE;\n    }\n\n    if (c > param.maxSize) {\n      return param.maxSize;\n    }\n    return c;\n  }\n\n  // prevent already started scroll, performance optimization\n  private cancelScroll(dimension: RevoGrid.DimensionType) {\n    const canceler = this.preventArtificialScroll[dimension];\n    if (canceler) {\n      canceler();\n      this.preventArtificialScroll[dimension] = null;\n    }\n  }\n\n  /* convert virtual to real and back, scale range */\n  private convert(pos: number, param: Params, toReal: boolean = true): number {\n    const minRange: number = param.clientSize;\n    const from: [number, number] = [0, param.virtualContentSize - minRange];\n    const to: [number, number] = [0, param.contentSize - param.virtualSize];\n    if (toReal) {\n      return scaleValue(pos, from, to);\n    }\n    return scaleValue(pos, to, from);\n  }\n}\n"],"mappings":"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"}