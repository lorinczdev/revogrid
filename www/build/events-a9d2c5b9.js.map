{"version":3,"names":["getUpdatedItemsByPosition","pos","items","realCount","virtualSize","dimension","activeItem","getItemByPosition","firstItem","getFirstItem","toUpdate","changedOffsetStart","itemIndex","recombineByOffset","Math","abs","Object","assign","positiveDirection","maxSizeVirtualSize","getMaxVirtualSize","realSize","extra","addMissingItems","length","updateMissingAndRange","getItems","firstItemStart","start","firstItemIndex","origSize","originItemSize","maxSize","maxCount","sizes","end","min","missing","range","splice","existingCollection","lastItem","getLastItem","opt","currentSize","index","size","newSize","getItemSize","push","offset","data","newItems","itemsCount","newRange","i","newIndex","newEnd","Error","newStart","isActiveRange","first","last","isActiveRangeOutsideLastItem","s","setItemSizes","vpItems","initialIndex","lastCoordinate","count","item","initialState","ViewportStore","this","lastKnownScroll","value","constructor","type","store","createStore","onChange","clearItems","setViewport","setViewPortCoordinate","position","viewportSize","get","frameOffset","singleOffsetInPx","outsize","maxCoordinate","allItems","setViewPortDimensionSizes","dropToOriginalSize","changedCoordinate","changedSize","setOriginalSizes","setStore","set","LETTER_BLOCK_SIZE","calculateRowHeaderSize","itemsLength","rowHeaderColumn","toString","isTouch","e","touches","verifyTouchTarget","touchEvent","focusClass","target","Element","classList","contains","getFromEvent","prop"],"sources":["src/store/viewPort/viewport.helpers.ts","src/store/viewPort/viewport.store.ts","src/utils/row-header-utils.ts","src/utils/events.ts"],"sourcesContent":["import { getItemByPosition } from '../dimension/dimension.helpers';\nimport { RevoGrid } from '../../interfaces';\n\nexport type DimensionDataViewport = Pick<\n  RevoGrid.DimensionSettingsState,\n  'indexes' | 'positionIndexes' | 'positionIndexToItem' | 'sizes' | 'originItemSize' | 'realSize'\n>;\n\ntype ItemsToUpdate = Pick<RevoGrid.ViewportStateItems, 'items' | 'start' | 'end'>;\n/**\n * Update items based on new scroll position\n * If viewport wasn't changed fully simple recombination of positions\n * Otherwise rebuild viewport items\n */\nexport function getUpdatedItemsByPosition<T extends ItemsToUpdate>(\n  pos: number, // coordinate\n  items: T,\n  realCount: number,\n  virtualSize: number,\n  dimension: DimensionDataViewport\n): ItemsToUpdate {\n  const activeItem: RevoGrid.PositionItem = getItemByPosition(dimension, pos);\n  const firstItem: RevoGrid.PositionItem = getFirstItem(items);\n  let toUpdate: ItemsToUpdate;\n  // do simple position recombination if items already present in viewport\n  if (firstItem) {\n    let changedOffsetStart = activeItem.itemIndex - (firstItem.itemIndex || 0);\n    // if item changed\n    if (changedOffsetStart) {\n      // simple recombination\n      toUpdate = recombineByOffset(Math.abs(changedOffsetStart), {\n        positiveDirection: changedOffsetStart > -1,\n        ...dimension,\n        ...items,\n      });\n    }\n  }\n\n  const maxSizeVirtualSize = getMaxVirtualSize(virtualSize, dimension.realSize, activeItem);\n  // if partial recombination add items if revo-viewport has some space left\n  if (toUpdate) {\n    const extra = addMissingItems(activeItem, realCount, maxSizeVirtualSize, toUpdate, dimension);\n    if (extra.length) {\n      updateMissingAndRange(toUpdate.items, extra, toUpdate);\n    }\n  }\n\n  // new collection if no items after replacement full replacement\n  if (!toUpdate) {\n    const items = getItems({\n      firstItemStart: activeItem.start,\n      firstItemIndex: activeItem.itemIndex,\n      origSize: dimension.originItemSize,\n      maxSize: maxSizeVirtualSize,\n      maxCount: realCount,\n      sizes: dimension.sizes,\n    });\n\n    // range now comes from 0 to length - 1\n    toUpdate = {\n      items,\n      start: 0,\n      end: items.length - 1,\n    };\n  }\n  return toUpdate;\n}\n\n// virtual size can differ based on scroll position if some big items are present\n// scroll can be in the middle of item and virtual size will be larger\n// so we need to exclude this part from virtual size hence it's already passed\nfunction getMaxVirtualSize(virtualSize: number, realSize: number, activeItem: RevoGrid.PositionItem) {\n  return Math.min(virtualSize + (activeItem.end - activeItem.start), realSize)\n}\n\nexport function updateMissingAndRange(\n  items: RevoGrid.VirtualPositionItem[],\n  missing: RevoGrid.VirtualPositionItem[],\n  range: RevoGrid.Range\n) {\n  items.splice(range.end + 1, 0, ...missing);\n  // update range if start larger after recombination\n  if (range.start >= range.end && !(range.start === range.end && range.start === 0)) {\n    range.start += missing.length;\n  }\n  range.end += missing.length;\n}\n\n/**\n * If partial replacement\n * this function adds items if viewport has some space left\n */\nexport function addMissingItems<T extends ItemsToUpdate>(\n  firstItem: RevoGrid.PositionItem,\n  realCount: number,\n  virtualSize: number,\n  existingCollection: T,\n  dimension: Pick<RevoGrid.DimensionSettingsState, 'sizes' | 'originItemSize'>,\n): RevoGrid.VirtualPositionItem[] {\n  const lastItem: RevoGrid.VirtualPositionItem = getLastItem(existingCollection);\n  const items = getItems({\n    sizes: dimension.sizes,\n    firstItemStart: lastItem.end,\n    firstItemIndex: lastItem.itemIndex + 1,\n    origSize: dimension.originItemSize,\n    maxSize: virtualSize - (lastItem.end - firstItem.start),\n    maxCount: realCount,\n  });\n  return items;\n}\n\n/**\n * Get wiewport items parameters\n * caching position and calculating items count in viewport\n */\nexport function getItems(\n  opt: {\n    firstItemIndex: number;\n    firstItemStart: number;\n    origSize: number;\n    maxSize: number; // virtual size\n    maxCount: number; // real item count, where the last item\n    sizes?: RevoGrid.ViewSettingSizeProp;\n  },\n  currentSize = 0,\n) {\n  const items: RevoGrid.VirtualPositionItem[] = [];\n\n  let index = opt.firstItemIndex;\n  let size = currentSize;\n\n  // max size or max count\n  while (size <= opt.maxSize && index < opt.maxCount) {\n    const newSize = getItemSize(index, opt.sizes, opt.origSize);\n    items.push({\n      start: opt.firstItemStart + size,\n      end: opt.firstItemStart + size + newSize,\n      itemIndex: index,\n      size: newSize,\n    });\n    size += newSize;\n    index++;\n  }\n  return items;\n}\n\n/**\n * Do batch items recombination\n * If items not overlapped with existing viewport returns null\n */\ntype RecombindDimensionData = Pick<RevoGrid.DimensionSettingsState, 'sizes' | 'realSize' | 'originItemSize'>;\ntype RecombineOffsetData = {\n  positiveDirection: boolean;\n} & ItemsToUpdate & RecombindDimensionData;\nexport function recombineByOffset(\n  offset: number,\n  data: RecombineOffsetData\n): ItemsToUpdate | null {\n  const newItems = [...data.items];\n  const itemsCount = newItems.length;\n  let newRange = {\n    start: data.start,\n    end: data.end,\n  };\n\n  // if offset out of revo-viewport, makes sense whole redraw\n  if (offset > itemsCount) {\n    return null;\n  }\n\n  // is direction of scroll positive\n  if (data.positiveDirection) {\n    // push item to the end\n    let lastItem: RevoGrid.VirtualPositionItem = getLastItem(data);\n\n    let i: number = newRange.start;\n    const length = i + offset;\n    for (; i < length; i++) {\n      const newIndex: number = lastItem.itemIndex + 1;\n      const size: number = getItemSize(newIndex, data.sizes, data.originItemSize);\n\n      // if item overlapped limit break a loop\n      if (lastItem.end + size > data.realSize) {\n        break;\n      }\n\n      // new item index to recombine\n      let newEnd = i % itemsCount;\n\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newEnd]) {\n        throw new Error('incorrect index');\n      }\n\n      // do recombination\n      newItems[newEnd] = lastItem = {\n        start: lastItem.end,\n        end: lastItem.end + size,\n        itemIndex: newIndex,\n        size: size,\n      };\n      // update range\n      newRange.start++;\n      newRange.end = newEnd;\n    }\n\n    // direction is negative\n  } else {\n    // push item to the start\n    let firstItem: RevoGrid.VirtualPositionItem = getFirstItem(data);\n\n    const end = newRange.end;\n    for (let i = 0; i < offset; i++) {\n      const newIndex: number = firstItem.itemIndex - 1;\n      const size: number = getItemSize(newIndex, data.sizes, data.originItemSize);\n\n      // new item index to recombine\n      let newStart = end - i;\n      newStart = (newStart < 0 ? itemsCount + newStart : newStart) % itemsCount;\n\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newStart]) {\n        throw new Error('incorrect index');\n      }\n\n      // do recombination\n      newItems[newStart] = firstItem = {\n        start: firstItem.start - size,\n        end: firstItem.start,\n        itemIndex: newIndex,\n        size: size,\n      };\n      // update range\n      newRange.start = newStart;\n      newRange.end--;\n    }\n  }\n  const range = {\n    start: (newRange.start < 0 ? itemsCount + newRange.start : newRange.start) % itemsCount,\n    end: (newRange.end < 0 ? itemsCount + newRange.end : newRange.end) % itemsCount,\n  };\n  return {\n    items: newItems,\n    ...range,\n  };\n}\n\nfunction getItemSize(index: number, sizes?: RevoGrid.ViewSettingSizeProp, origSize: number = 0): number {\n  if (sizes && sizes[index]) {\n    return sizes[index];\n  }\n  return origSize;\n}\n\n/**\n * Verify if position is in range of the PositionItem, start and end are included\n */\nexport function isActiveRange(\n  pos: number,\n  realSize: number,\n  first?: RevoGrid.PositionItem,\n  last?: RevoGrid.PositionItem\n): boolean {\n  if (!first || !last) {\n    return false;\n  }\n  // if position is in range of first item\n  // or position is after first item and last item is the last item in real size\n  return pos >= first.start && pos <= first.end ||\n    pos > first.end && last.end === realSize;\n}\n\nexport function isActiveRangeOutsideLastItem(pos: number, virtualSize: number, firstItem?: RevoGrid.PositionItem, lastItem?: RevoGrid.PositionItem) {\n  // if no first item, means no items in viewport\n  if (!firstItem) {\n    return false;\n  }\n  return virtualSize + pos > lastItem?.end\n}\n\nexport function getFirstItem(s: ItemsToUpdate): RevoGrid.VirtualPositionItem | undefined {\n  return s.items[s.start];\n}\n\nexport function getLastItem(s: ItemsToUpdate): RevoGrid.VirtualPositionItem {\n  return s.items[s.end];\n}\n\n/**\n * Set items sizes from start index to end\n * @param vpItems \n * @param start \n * @param size \n * @param lastCoordinate \n * @returns \n */\nexport function setItemSizes(\n  vpItems: RevoGrid.VirtualPositionItem[],\n  initialIndex: number,\n  size: number,\n  lastCoordinate: number\n) {\n  const items = [...vpItems];\n  const count = items.length;\n\n  let pos = lastCoordinate;\n  let i = 0;\n  let start = initialIndex;\n\n  // viewport not inited\n  if (!count) {\n    return [];\n  }\n   // loop through array from initial item after recombination\n   while (i < count) {\n    const item = items[start];\n    item.start = pos;\n    item.size = size;\n    item.end = item.start + size;\n    pos = item.end;\n    // loop by start index\n    start++;\n    i++;\n\n    // if start index out of array, reset it\n    if (start === count) {\n      start = 0;\n    }\n  }\n  return items;\n}\n","/**\n * Store is responsible for visible\n * Viewport information for each dimension\n * Redraw items during scrolling\n */\n\nimport { createStore } from '@stencil/store';\n\nimport {\n  addMissingItems,\n  DimensionDataViewport,\n  getFirstItem,\n  getLastItem,\n  getUpdatedItemsByPosition,\n  isActiveRange,\n  setItemSizes,\n  updateMissingAndRange,\n  isActiveRangeOutsideLastItem,\n} from './viewport.helpers';\n\nimport { setStore } from '../../utils/store.utils';\nimport { Observable, RevoGrid } from '../../interfaces';\n\nfunction initialState(): RevoGrid.ViewportState {\n  return {\n    // virtual item information per rendered item\n    items: [],\n    // virtual dom item order to render\n    start: 0,\n\n    end: 0,\n\n    // size of viewport in px\n    virtualSize: 0,\n\n    // total number of items\n    realCount: 0,\n  };\n}\n\nexport default class ViewportStore {\n  readonly store: Observable<RevoGrid.ViewportState>;\n  // last coordinate for store position restore\n  private lastKnownScroll = 0;\n  get lastCoordinate() {\n    return this.lastKnownScroll;\n  }\n  private set lastCoordinate(value: number) {\n    this.lastKnownScroll = value;\n  }\n  constructor(readonly type: RevoGrid.MultiDimensionType) {\n    this.store = createStore(initialState());\n    this.store.onChange('realCount', () => this.clearItems());\n    // drop items on virtual size change, require a new item set\n    this.store.onChange('virtualSize', () => this.setViewport({ items: [] }));\n  }\n\n  /**\n   * Render viewport based on coordinate\n   * It's the main method for draw\n   */\n  setViewPortCoordinate(position: number, dimension: DimensionDataViewport) {\n    const viewportSize = this.store.get('virtualSize');\n    // no visible data to calculate\n    if (!viewportSize) {\n      return;\n    }\n\n    const frameOffset = 1;\n    const singleOffsetInPx = dimension.originItemSize * frameOffset;\n    // add offset to virtual size from both sides\n    const outsize = singleOffsetInPx * 2;\n    // math virtual size is based on visible area + 2 items outside of visible area\n    const virtualSize = viewportSize + outsize;\n\n    // expected no scroll if real size less than virtual size, position is 0\n    let maxCoordinate = 0;\n    // if there is nodes outside of viewport, max coordinate has to be adjusted\n    if (dimension.realSize > viewportSize) {\n      // max coordinate is real size minus virtual/rendered space\n      maxCoordinate = dimension.realSize - viewportSize - singleOffsetInPx;\n    }\n\n    let pos = position;\n    // limit position to max and min coordinates\n    if (pos < 0) {\n      pos = 0;\n    } else if (pos > maxCoordinate) {\n      pos = maxCoordinate;\n    }\n\n    // store last coordinate for further restore on redraw\n    this.lastCoordinate = pos;\n\n    // actual position is less than first item start based on offset\n    pos -= singleOffsetInPx;\n    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;\n\n    const allItems = this.getItems();\n    const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n    const lastItem: RevoGrid.VirtualPositionItem | undefined = getLastItem(allItems);\n\n\n    let toUpdate: Partial<RevoGrid.ViewportState> = {};\n    // left position changed\n    // verify if new position is in range of previously rendered first item\n    if (!isActiveRange(pos, dimension.realSize, firstItem, lastItem)) {\n      toUpdate = {\n        ...toUpdate,\n        ...getUpdatedItemsByPosition(pos, allItems, this.store.get('realCount'), virtualSize, dimension),\n      };\n      this.setViewport({ ...toUpdate });\n    // verify is render area is outside of last item\n    } else if (isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem)) {\n      // check is any item missing for full fill content\n      const missing = addMissingItems(firstItem, this.store.get('realCount'), virtualSize + pos - firstItem.start, allItems, dimension);\n\n      // update missing items\n      if (missing.length) {\n        const items = [...this.store.get('items')];\n        const range = {\n          start: this.store.get('start'),\n          end: this.store.get('end'),\n        };\n        updateMissingAndRange(items, missing, range);\n        toUpdate = {\n          ...toUpdate,\n          items: [...items],\n          ...range,\n        };\n        this.setViewport({ ...toUpdate });\n      }\n    }\n  }\n\n  /**\n   * Update viewport sizes for existing items\n   * This method is generating new item positions based on custom sizes and original sizes\n   * @param sizes - custom sizes for each item\n   * @param dropToOriginalSize - drop to original size if requested\n   */\n  setViewPortDimensionSizes(sizes: RevoGrid.ViewSettingSizeProp, dropToOriginalSize?: number) {\n    let items = [...this.store.get('items')];\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    let changedCoordinate = 0;\n    let i = 0;\n    let start = this.store.get('start');\n\n    // drop to original size if requested\n    if (dropToOriginalSize) {\n      const allItems = this.getItems();\n      const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n      items = setItemSizes(items, start, dropToOriginalSize, firstItem.start);\n    }\n\n    // loop through array from initial item after recombination\n    // if size change present, change position for all items after\n    while (i < count) {\n      const item = items[start];\n      // change pos if size change present before\n      if (changedCoordinate) {\n        item.start += changedCoordinate;\n        item.end += changedCoordinate;\n      }\n      // check if size change present\n      const size: number | undefined = sizes[item.itemIndex];\n      // size found\n      if (size) {\n        const changedSize = size - item.size;\n        changedCoordinate += changedSize;\n        item.size = size;\n        item.end = item.start + size;\n        // size lost\n      }\n\n      // loop by start index\n      start++;\n      i++;\n      // if start index out of array, reset it\n      if (start === count) {\n        start = 0;\n      }\n    }\n\n    this.setViewport({ items: [...items] });\n  }\n\n  /**\n   * Set sizes for existing items\n   */\n  setOriginalSizes(size: number) {\n    const items = this.store.get('items');\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    setStore(this.store, {\n      items: setItemSizes(items, this.store.get('start'), size, this.lastCoordinate),\n    });\n  }\n\n  getItems(): Pick<RevoGrid.ViewportStateItems, 'items' | 'start' | 'end'> {\n    return {\n      items: this.store.get('items'),\n      start: this.store.get('start'),\n      end: this.store.get('end'),\n    };\n  }\n\n  setViewport(data: Partial<RevoGrid.ViewportState>) {\n    setStore(this.store, data);\n  }\n\n  clearItems() {\n    this.store.set('items', []);\n  }\n}\n","import { RevoGrid } from '../interfaces';\n\nconst LETTER_BLOCK_SIZE = 10;\nexport const calculateRowHeaderSize = (itemsLength: number, rowHeaderColumn?: RevoGrid.RowHeaders) => {\n  return rowHeaderColumn?.size || (itemsLength.toString().length + 1) * LETTER_BLOCK_SIZE;\n};\n","function isTouch(e: MouseEvent | TouchEvent): e is TouchEvent {\n  return !!(e as TouchEvent).touches;\n}\n\nexport function verifyTouchTarget(touchEvent?: Touch, focusClass?: string) {\n  if (focusClass && touchEvent) {\n    if (!(touchEvent.target instanceof Element && touchEvent.target.classList.contains(focusClass))) { \n      return false;\n    }\n  }\n  return true;\n}\n\n\nexport function getFromEvent(\n  e: MouseEvent | TouchEvent,\n  prop: keyof Pick<Touch, 'clientX' | 'clientY' | 'screenX' | 'screenY'>,\n  focusClass?: string // for touch events\n): number | null {\n  if (isTouch(e)) {\n    if (e.touches.length > 0) {\n      const touchEvent = e.touches[0];\n      if (!verifyTouchTarget(touchEvent, focusClass)) {\n        return null;\n      }\n      return (touchEvent[prop] as number) || 0;\n    }\n    return null;\n  }\n  return e[prop] || 0;\n}\n"],"mappings":"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"}