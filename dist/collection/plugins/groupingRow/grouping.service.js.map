{"version":3,"file":"grouping.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { RevoGrid } from '../../interfaces';\nimport {\n  GROUP_DEPTH,\n  GROUP_EXPANDED,\n  PSEUDO_GROUP_COLUMN,\n  PSEUDO_GROUP_ITEM,\n  PSEUDO_GROUP_ITEM_ID,\n  PSEUDO_GROUP_ITEM_VALUE,\n  GROUP_ORIGINAL_INDEX,\n} from './grouping.const';\nimport { GroupLabelTemplateFunc } from './grouping.row.types';\n\nexport type ExpandedOptions = {\n  prevExpanded?: Record<string, boolean>;\n  expandedAll?: boolean; // skip trim\n\n  getGroupValue?(item: RevoGrid.DataType, prop: string | number): any;\n  groupLabelTemplate?: GroupLabelTemplateFunc;\n};\n\ntype GroupedData = Map<string, GroupedData | RevoGrid.DataType[]>;\n\nfunction getGroupValueDefault(item: RevoGrid.DataType, prop: string | number) {\n  return item[prop] || null;\n}\n\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param groupIds - ids of groups\n * @param expanded - potentially expanded items if present\n */\nexport function gatherGrouping(\n  array: RevoGrid.DataType[],\n  groupIds: RevoGrid.ColumnProp[],\n  { prevExpanded, expandedAll, getGroupValue = getGroupValueDefault }: ExpandedOptions,\n) {\n  const groupedItems: GroupedData = new Map();\n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = groupIds.map(groupId => getGroupValue(item, groupId));\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value) as GroupedData;\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      currentGroupLevel.set(lastLevelValue, []);\n    }\n    const lastLevelItems = currentGroupLevel.get(\n      lastLevelValue,\n    ) as RevoGrid.DataType[];\n    lastLevelItems.push({\n      ...item,\n      [GROUP_ORIGINAL_INDEX]: originalIndex,\n    });\n  });\n\n  let itemIndex = -1;\n  const groupingDepth = groupIds.length;\n  // collapse all groups in the beginning\n  const trimmed: Record<number, boolean> = {};\n  // index mapping\n  const oldNewIndexMap: Record<number, number> = {};\n  // check if group header exists\n  const pseudoGroupTest: Record<string, number[]> = {};\n  const sourceWithGroups: RevoGrid.DataType[] = [];\n  function flattenGroupMaps(\n    groupedValues: GroupedData,\n    parentIds: string[],\n    isExpanded: boolean,\n  ) {\n    const depth = parentIds.length;\n    groupedValues.forEach((innerGroupedValues, groupId) => {\n      const levelIds = [...parentIds, groupId];\n      const mergedIds = levelIds.join(',');\n      const isGroupExpanded =\n        isExpanded && (!!expandedAll || !!prevExpanded?.[mergedIds]);\n      sourceWithGroups.push({\n        [PSEUDO_GROUP_ITEM]: groupId,\n        [GROUP_DEPTH]: depth,\n        [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n        [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n        [GROUP_EXPANDED]: isGroupExpanded,\n      });\n      itemIndex += 1;\n      if (!isGroupExpanded && depth) {\n        trimmed[itemIndex] = true;\n      }\n      if (Array.isArray(innerGroupedValues)) {\n        innerGroupedValues.forEach(value => {\n          itemIndex += 1;\n          if (!isGroupExpanded) {\n            trimmed[itemIndex] = true;\n          }\n          oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex;\n          const pseudoGroupTestIds = levelIds.map((_value, index) =>\n            levelIds.slice(0, index + 1).join(','),\n          );\n          pseudoGroupTestIds.forEach(pseudoGroupTestId => {\n            if (!pseudoGroupTest[pseudoGroupTestId]) {\n              pseudoGroupTest[pseudoGroupTestId] = [];\n            }\n            pseudoGroupTest[pseudoGroupTestId].push(itemIndex);\n          });\n        });\n        sourceWithGroups.push(...innerGroupedValues);\n      } else {\n        flattenGroupMaps(innerGroupedValues, levelIds, isGroupExpanded);\n      }\n    });\n  }\n  flattenGroupMaps(groupedItems, [], true);\n\n  return {\n    sourceWithGroups, // updates source mirror\n    depth: groupingDepth, // largest depth for grouping\n    trimmed, // used for expand/collapse grouping values\n    oldNewIndexMap, // used for mapping old values to new\n    childrenByGroup: pseudoGroupTest, // used to get child items in group\n  };\n}\n\nexport function getGroupingName(rgRow?: RevoGrid.DataType) {\n  return rgRow && rgRow[PSEUDO_GROUP_ITEM];\n}\n\nexport function isGrouping(rgRow?: RevoGrid.DataType) {\n  return rgRow && typeof rgRow[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\n\nexport function isGroupingColumn(column?: RevoGrid.ColumnRegular) {\n  return column && typeof column[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\n\nexport function measureEqualDepth<T>(groupA: T[], groupB: T[]) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\n\nexport function getParsedGroup(id: string): any[] {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safe guard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n\n// check if items is child of current clicked group\nexport function isSameGroup(\n  currentGroup: any[],\n  currentModel: RevoGrid.DataType,\n  nextModel: RevoGrid.DataType,\n) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\n"]}