{"version":3,"file":"grouping.trimmed.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.trimmed.service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAA0B,MAAM,uCAAuC,CAAC;AAEnG,MAAM,CAAC,MAAM,gBAAgB,GAAG,UAAU,CAAC;AAE3C;;;;;GAKG;AACH,MAAM,UAAU,8BAA8B,CAAC,eAAwB,EAAE,aAAqC,EAAE,cAAuC;EACrJ,MAAM,wBAAwB,GAAY,EAAE,CAAC;EAC7C;;KAEG;EACH,KAAK,IAAI,IAAI,IAAI,eAAe,EAAE;IAChC,IAAI,IAAI,KAAK,gBAAgB,EAAE;MAC7B,SAAS;KACV;IACD,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAkB,EAAE,CAAC;IAEnC,KAAK,IAAI,YAAY,IAAI,KAAK,EAAE;MAC9B;;;SAGG;MACH,IAAI,kBAAkB,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;MACrD,IAAI,cAAc,EAAE;QAClB,kBAAkB,GAAG,cAAc,CAAC,kBAAkB,CAAC,CAAC;OACzD;MAED;;;SAGG;MACH,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE;QACvB,QAAQ,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC;QACpC;;WAEG;QACH,IAAI,kBAAkB,KAAK,QAAQ,CAAC,YAAY,EAAE,EAAE,CAAC,EAAE;UACrD,wBAAwB,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;SAC3C;OACF;KACF;GACF;EACD,OAAO,wBAAwB,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,gBAAyB,EAAE,kBAA4C,EAAE;EAC5G,MAAM,YAAY,GAAkB,EAAE,CAAC;EACvC,MAAM,UAAU,GAAG,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;EACxD,4BAA4B;EAC5B,KAAK,IAAI,UAAU,IAAI,eAAe,EAAE;IACtC,MAAM,WAAW,GAAG,eAAe,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;IACzG,IAAI,CAAC,WAAW,EAAE;MAChB,YAAY,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;KACjC;GACF;EACD,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["import { gatherTrimmedItems, Trimmed, TrimmedEntity } from '../../store/dataSource/trimmed.plugin';\n\nexport const TRIMMED_GROUPING = 'grouping';\n\n/**\n * Prepare trimming updated indexes for grouping\n * @param initiallyTrimed\n * @param firstLevelMap\n * @param secondLevelMap\n */\nexport function processDoubleConversionTrimmed(initiallyTrimed: Trimmed, firstLevelMap: Record<number, number>, secondLevelMap?: Record<number, number>) {\n  const trimemedOptionsToUpgrade: Trimmed = {};\n  /**\n   * go through all groups except grouping\n   */\n  for (let type in initiallyTrimed) {\n    if (type === TRIMMED_GROUPING) {\n      continue;\n    }\n    const items = initiallyTrimed[type];\n    const newItems: TrimmedEntity = {};\n\n    for (let initialIndex in items) {\n      /**\n       * if item exists we find it in collection\n       * we support 2 level of conversions\n       */\n      let newConversionIndex = firstLevelMap[initialIndex];\n      if (secondLevelMap) {\n        newConversionIndex = secondLevelMap[newConversionIndex];\n      }\n\n      /**\n       * if item was trimmed previously\n       * trimming makes sense to apply\n       */\n      if (items[initialIndex]) {\n        newItems[newConversionIndex] = true;\n        /**\n         * If changes present apply changes to new source\n         */\n        if (newConversionIndex !== parseInt(initialIndex, 10)) {\n          trimemedOptionsToUpgrade[type] = newItems;\n        }\n      }\n    }\n  }\n  return trimemedOptionsToUpgrade;\n}\n\nexport function filterOutEmptyGroups(allTrimmedGroups: Trimmed, childrenByGroup: Record<number, number[]> = {}) {\n  const trimmedGroup: TrimmedEntity = {};\n  const allTrimmed = gatherTrimmedItems(allTrimmedGroups);\n  // find is groups are filled\n  for (let groupIndex in childrenByGroup) {\n    const hasChidlren = childrenByGroup[groupIndex].filter(childIndex => !allTrimmed[childIndex]).length > 0;\n    if (!hasChidlren) {\n      trimmedGroup[groupIndex] = true;\n    }\n  }\n  return trimmedGroup;\n}\n"]}