{"version":3,"file":"grouping.row.expand.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.row.expand.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { RevoGrid } from '../../interfaces';\nimport { PSEUDO_GROUP_ITEM_ID, PSEUDO_GROUP_ITEM_VALUE, GROUP_EXPANDED, GROUP_DEPTH } from './grouping.const';\nimport { isGrouping, getParsedGroup, isSameGroup } from './grouping.service';\n\n// provide collapse data\nexport function doCollapse(pIndex: number, source: RevoGrid.DataType[]) {\n  const model = source[pIndex];\n  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];\n  const trimmed: Record<number, boolean> = {};\n  let i = pIndex + 1;\n  const total = source.length;\n  while (i < total) {\n    const currentModel = source[i];\n    if (isGrouping(currentModel)) {\n      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];\n      if (!currentValue.length || !currentValue.startsWith(collapseValue + ',')) {\n        break;\n      }\n      currentModel[GROUP_EXPANDED] = false;\n    }\n    trimmed[i++] = true;\n  }\n  model[GROUP_EXPANDED] = false;\n  return { trimmed };\n}\n\n/**\n *\n * @param pIndex - physical index\n * @param vIndex - virtual index, need to update item collection\n * @param source - data source\n * @param rowItemsIndexes - rgRow indexes\n */\nexport function doExpand(vIndex: number, source: RevoGrid.DataType[], rowItemsIndexes: number[]) {\n  const physicalIndex = rowItemsIndexes[vIndex];\n  const model = source[physicalIndex];\n  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);\n  const trimmed: Record<number, boolean> = {};\n\n  // no group found\n  if (!currentGroup) {\n    return { trimmed };\n  }\n\n  const groupItems: number[] = [];\n  model[GROUP_EXPANDED] = true;\n  let i = physicalIndex + 1;\n  const total = source.length;\n  let groupLevelOnly = 0;\n\n  // go through all rows\n  while (i < total) {\n    const currentModel = source[i];\n    const isGroup = isGrouping(currentModel);\n    // group found\n    if (isGroup) {\n      if (!isSameGroup(currentGroup, model, currentModel)) {\n        break;\n      } else if (!groupLevelOnly) {\n        // if get group first it's group only level\n        groupLevelOnly = currentModel[GROUP_DEPTH];\n      }\n    }\n    // level 0 or same depth\n    if (!groupLevelOnly || (isGroup && groupLevelOnly === currentModel[GROUP_DEPTH])) {\n      trimmed[i] = false;\n      groupItems.push(i);\n    }\n    i++;\n  }\n  const result: {\n    trimmed: Record<number, boolean>;\n    items?: number[];\n  } = {\n    trimmed,\n  };\n  if (groupItems.length) {\n    const items = [...rowItemsIndexes];\n    items.splice(vIndex + 1, 0, ...groupItems);\n    result.items = items;\n  }\n  return result;\n}\n"]}