{"version":3,"file":"selection.helpers.js","sourceRoot":"","sources":["../../../src/store/selection/selection.helpers.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,0CAA0C,CAAC;AAIvE,MAAM,UAAU,aAAa,CAAC,GAAW;EACvC,OAAO,GAAG,KAAK,WAAW,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,IAAU,EAAE,QAAc;EACjD,MAAM,QAAQ,GAAkB,EAAE,CAAC;EACnC,IAAI,KAAK,GAAmB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAEvC,sBAAsB;EACtB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;IACnB,IAAI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACf,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;MACtB,OAAO,QAAQ,CAAC;KACjB;GACF;EACD,kBAAkB;EAClB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;IACnB,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;MAC1B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;MACpC,OAAO,QAAQ,CAAC;KACjB;GACF;EACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,IAAU,EAAE,QAAc;EACtD,MAAM,OAAO,qBAAc,IAAI,CAAE,CAAC;EAClC,IAAI,KAAK,GAAmB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EACvC,sBAAsB;EACtB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;IACnB,IAAI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACf,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KAChB;GACF;EACD,kBAAkB;EAClB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;IACnB,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;MAC1B,OAAO,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KAC9B;GACF;EACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,KAAY,EAAE,GAAU;EAC/C,OAAO,KAAK,IAAI,GAAG;IACjB,CAAC,CAAC;MACE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MAC3B,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MAC3B,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MAC5B,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;KAC7B;IACH,CAAC,CAAC,IAAI,CAAC;AACX,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,CAAY;EAC5C,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;AACtC,CAAC","sourcesContent":["import { Selection } from '../../interfaces';\nimport { EMPTY_INDEX } from '../../services/selection.store.connector';\nimport Cell = Selection.Cell;\nimport RangeArea = Selection.RangeArea;\n\nexport function isHiddenStore(pos: number) {\n  return pos === EMPTY_INDEX;\n}\n\nexport function nextCell(cell: Cell, lastCell: Cell): Partial<Cell> | null {\n  const nextItem: Partial<Cell> = {};\n  let types: (keyof Cell)[] = ['x', 'y'];\n\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      nextItem[t] = cell[t];\n      return nextItem;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      nextItem[t] = cell[t] - lastCell[t];\n      return nextItem;\n    }\n  }\n  return null;\n}\n\nexport function cropCellToMax(cell: Cell, lastCell: Cell): Cell {\n  const newCell: Cell = { ...cell };\n  let types: (keyof Cell)[] = ['x', 'y'];\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      newCell[t] = 0;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      newCell[t] = lastCell[t] - 1;\n    }\n  }\n  return newCell;\n}\n\nexport function getRange(start?: Cell, end?: Cell): RangeArea | null {\n  return start && end\n    ? {\n        x: Math.min(start.x, end.x),\n        y: Math.min(start.y, end.y),\n        x1: Math.max(start.x, end.x),\n        y1: Math.max(start.y, end.y),\n      }\n    : null;\n}\n\nexport function isRangeSingleCell(a: RangeArea): boolean {\n  return a.x === a.x1 && a.y === a.y1;\n}\n"]}