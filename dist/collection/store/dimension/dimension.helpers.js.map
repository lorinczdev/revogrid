{"version":3,"file":"dimension.helpers.js","sourceRoot":"","sources":["../../../src/store/dimension/dimension.helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import each from 'lodash/each';\nimport sortedIndex from 'lodash/sortedIndex';\nimport reduce from 'lodash/reduce';\nimport { RevoGrid } from '../../interfaces';\n\nexport type DimensionPosition = Pick<RevoGrid.DimensionSettingsState, 'indexes' | 'positionIndexes' | 'originItemSize' | 'positionIndexToItem'>;\nexport type DimensionIndexInput = Pick<RevoGrid.DimensionSettingsState, 'indexes' | 'originItemSize' | 'indexToItem'>;\nexport type DimensionSize = Pick<RevoGrid.DimensionSettingsState, 'indexes' | 'positionIndexes' | 'positionIndexToItem' | 'indexToItem' | 'realSize' | 'sizes'>;\n/**\n * Pre-calculation\n * Dimension custom sizes for each cell\n * Keeps only changed sizes, skips origin size\n */\nexport function calculateDimensionData(\n  originItemSize: number,\n  newSizes: RevoGrid.ViewSettingSizeProp = {}\n) {\n  const positionIndexes: number[] = [];\n  const positionIndexToItem: { [position: number]: RevoGrid.PositionItem } = {};\n  const indexToItem: { [index: number]: RevoGrid.PositionItem } = {};\n\n  // combine all new sizes\n  const sizes = { ...newSizes };\n  // prepare order sorted new sizes and calculate changed real size\n  let newIndexes: number[] = [];\n  each(newSizes, (_, i) => {\n    const index = parseInt(i, 10);\n    newIndexes[sortedIndex(newIndexes, index)] = index;\n  });\n  // fill new coordinates based on what is changed\n  reduce(\n    newIndexes,\n    (previous: RevoGrid.PositionItem | undefined, itemIndex: number, i: number) => {\n      const newItem: RevoGrid.PositionItem = {\n        itemIndex,\n        start: 0,\n        end: 0,\n      };\n      // if previous item was changed too\n      if (previous) {\n        const itemsBetween = (itemIndex - previous.itemIndex - 1) * originItemSize;\n        newItem.start = itemsBetween + previous.end;\n      } else {\n        newItem.start = itemIndex * originItemSize;\n      }\n      newItem.end = newItem.start + sizes[itemIndex];\n      positionIndexes.push(newItem.start);\n      indexToItem[itemIndex] = positionIndexToItem[i] = newItem;\n      return newItem;\n    },\n    undefined,\n  );\n\n  return {\n    indexes: newIndexes,\n    positionIndexes: [...positionIndexes],\n    positionIndexToItem: { ...positionIndexToItem },\n    indexToItem,\n    sizes,\n  };\n}\n\n/**\n * Calculate item by position\n */\nexport function getItemByPosition({ indexes, positionIndexes, originItemSize, positionIndexToItem }: DimensionPosition, pos: number) {\n  const item: RevoGrid.PositionItem = {\n    itemIndex: 0,\n    start: 0,\n    end: 0,\n  };\n  const currentPlace = indexes.length ? sortedIndex(positionIndexes, pos) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.itemIndex = Math.floor(pos / originItemSize);\n    item.start = item.itemIndex * originItemSize;\n    item.end = item.start + originItemSize;\n    return item;\n  }\n  const positionItem = positionIndexToItem[currentPlace - 1];\n  // if item has specified size\n  if (positionItem.end > pos) {\n    return positionItem;\n  }\n  // special size item was present before\n  const relativePos = pos - positionItem.end;\n  const relativeIndex = Math.floor(relativePos / originItemSize);\n  item.itemIndex = positionItem.itemIndex + 1 + relativeIndex;\n  item.start = positionItem.end + relativeIndex * originItemSize;\n  item.end = item.start + originItemSize;\n  return item;\n}\n\nexport function getItemByIndex(dimension: DimensionIndexInput, index: number) {\n  let item: RevoGrid.PositionItem = {\n    itemIndex: index,\n    start: 0,\n    end: 0,\n  };\n  // if item has specified size\n  if (dimension.indexToItem[index]) {\n    return dimension.indexToItem[index];\n  }\n\n  const currentPlace = dimension.indexes.length ? sortedIndex(dimension.indexes, index) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.start = item.itemIndex * dimension.originItemSize;\n    item.end = item.start + dimension.originItemSize;\n    return item;\n  }\n  // special size item was present before\n\n  const positionItem = dimension.indexToItem[dimension.indexes[currentPlace - 1]];\n  item.start = positionItem.end + (index - positionItem.itemIndex - 1) * dimension.originItemSize;\n  item.end = item.start + dimension.originItemSize;\n  return item;\n}\n"]}