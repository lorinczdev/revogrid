{"version":3,"file":"viewport.store.js","sourceRoot":"","sources":["../../../src/store/viewPort/viewport.store.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Store is responsible for visible\n * Viewport information for each dimension\n * Redraw items during scrolling\n */\n\nimport { createStore } from '@stencil/store';\n\nimport {\n  addMissingItems,\n  DimensionDataViewport,\n  getFirstItem,\n  getLastItem,\n  getUpdatedItemsByPosition,\n  isActiveRange,\n  setItemSizes,\n  updateMissingAndRange,\n  isActiveRangeOutsideLastItem,\n} from './viewport.helpers';\n\nimport { setStore } from '../../utils/store.utils';\nimport { Observable, RevoGrid } from '../../interfaces';\n\nfunction initialState(): RevoGrid.ViewportState {\n  return {\n    // virtual item information per rendered item\n    items: [],\n    // virtual dom item order to render\n    start: 0,\n\n    end: 0,\n\n    // size of viewport in px\n    virtualSize: 0,\n\n    // total number of items\n    realCount: 0,\n  };\n}\n\nexport default class ViewportStore {\n  readonly store: Observable<RevoGrid.ViewportState>;\n  // last coordinate for store position restore\n  private lastKnownScroll = 0;\n  get lastCoordinate() {\n    return this.lastKnownScroll;\n  }\n  private set lastCoordinate(value: number) {\n    this.lastKnownScroll = value;\n  }\n  constructor(readonly type: RevoGrid.MultiDimensionType) {\n    this.store = createStore(initialState());\n    this.store.onChange('realCount', () => this.clearItems());\n    // drop items on virtual size change, require a new item set\n    this.store.onChange('virtualSize', () => this.setViewport({ items: [] }));\n  }\n\n  /**\n   * Render viewport based on coordinate\n   * It's the main method for draw\n   */\n  setViewPortCoordinate(position: number, dimension: DimensionDataViewport) {\n    const viewportSize = this.store.get('virtualSize');\n    // no visible data to calculate\n    if (!viewportSize) {\n      return;\n    }\n\n    const frameOffset = 1;\n    const singleOffsetInPx = dimension.originItemSize * frameOffset;\n    // add offset to virtual size from both sides\n    const outsize = singleOffsetInPx * 2;\n    // math virtual size is based on visible area + 2 items outside of visible area\n    const virtualSize = viewportSize + outsize;\n\n    // expected no scroll if real size less than virtual size, position is 0\n    let maxCoordinate = 0;\n    // if there is nodes outside of viewport, max coordinate has to be adjusted\n    if (dimension.realSize > viewportSize) {\n      // max coordinate is real size minus virtual/rendered space\n      maxCoordinate = dimension.realSize - viewportSize - singleOffsetInPx;\n    }\n\n    let pos = position;\n    // limit position to max and min coordinates\n    if (pos < 0) {\n      pos = 0;\n    } else if (pos > maxCoordinate) {\n      pos = maxCoordinate;\n    }\n\n    // store last coordinate for further restore on redraw\n    this.lastCoordinate = pos;\n\n    // actual position is less than first item start based on offset\n    pos -= singleOffsetInPx;\n    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;\n\n    const allItems = this.getItems();\n    const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n    const lastItem: RevoGrid.VirtualPositionItem | undefined = getLastItem(allItems);\n\n\n    let toUpdate: Partial<RevoGrid.ViewportState> = {};\n    // left position changed\n    // verify if new position is in range of previously rendered first item\n    if (!isActiveRange(pos, dimension.realSize, firstItem, lastItem)) {\n      toUpdate = {\n        ...toUpdate,\n        ...getUpdatedItemsByPosition(pos, allItems, this.store.get('realCount'), virtualSize, dimension),\n      };\n      this.setViewport({ ...toUpdate });\n    // verify is render area is outside of last item\n    } else if (isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem)) {\n      // check is any item missing for full fill content\n      const missing = addMissingItems(firstItem, this.store.get('realCount'), virtualSize + pos - firstItem.start, allItems, dimension);\n\n      // update missing items\n      if (missing.length) {\n        const items = [...this.store.get('items')];\n        const range = {\n          start: this.store.get('start'),\n          end: this.store.get('end'),\n        };\n        updateMissingAndRange(items, missing, range);\n        toUpdate = {\n          ...toUpdate,\n          items: [...items],\n          ...range,\n        };\n        this.setViewport({ ...toUpdate });\n      }\n    }\n  }\n\n  /**\n   * Update viewport sizes for existing items\n   * This method is generating new item positions based on custom sizes and original sizes\n   * @param sizes - custom sizes for each item\n   * @param dropToOriginalSize - drop to original size if requested\n   */\n  setViewPortDimensionSizes(sizes: RevoGrid.ViewSettingSizeProp, dropToOriginalSize?: number) {\n    let items = [...this.store.get('items')];\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    let changedCoordinate = 0;\n    let i = 0;\n    let start = this.store.get('start');\n\n    // drop to original size if requested\n    if (dropToOriginalSize) {\n      const allItems = this.getItems();\n      const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n      items = setItemSizes(items, start, dropToOriginalSize, firstItem.start);\n    }\n\n    // loop through array from initial item after recombination\n    // if size change present, change position for all items after\n    while (i < count) {\n      const item = items[start];\n      // change pos if size change present before\n      if (changedCoordinate) {\n        item.start += changedCoordinate;\n        item.end += changedCoordinate;\n      }\n      // check if size change present\n      const size: number | undefined = sizes[item.itemIndex];\n      // size found\n      if (size) {\n        const changedSize = size - item.size;\n        changedCoordinate += changedSize;\n        item.size = size;\n        item.end = item.start + size;\n        // size lost\n      }\n\n      // loop by start index\n      start++;\n      i++;\n      // if start index out of array, reset it\n      if (start === count) {\n        start = 0;\n      }\n    }\n\n    this.setViewport({ items: [...items] });\n  }\n\n  /**\n   * Set sizes for existing items\n   */\n  setOriginalSizes(size: number) {\n    const items = this.store.get('items');\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    setStore(this.store, {\n      items: setItemSizes(items, this.store.get('start'), size, this.lastCoordinate),\n    });\n  }\n\n  getItems(): Pick<RevoGrid.ViewportStateItems, 'items' | 'start' | 'end'> {\n    return {\n      items: this.store.get('items'),\n      start: this.store.get('start'),\n      end: this.store.get('end'),\n    };\n  }\n\n  setViewport(data: Partial<RevoGrid.ViewportState>) {\n    setStore(this.store, data);\n  }\n\n  clearItems() {\n    this.store.set('items', []);\n  }\n}\n"]}