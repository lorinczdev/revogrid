{"file":"revogr-row-headers2.js","mappings":"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","names":[],"sources":["src/store/viewPort/viewport.helpers.ts","src/store/viewPort/viewport.store.ts","src/utils/row-header-utils.ts","src/components/rowHeaders/row-header-render.tsx","src/components/rowHeaders/revogr-row-headers.tsx"],"sourcesContent":["import { getItemByPosition } from '../dimension/dimension.helpers';\nimport { RevoGrid } from '../../interfaces';\n\nexport type DimensionDataViewport = Pick<\n  RevoGrid.DimensionSettingsState,\n  'indexes' | 'positionIndexes' | 'positionIndexToItem' | 'sizes' | 'originItemSize' | 'realSize'\n>;\n\ntype ItemsToUpdate = Pick<RevoGrid.ViewportStateItems, 'items' | 'start' | 'end'>;\n/**\n * Update items based on new scroll position\n * If viewport wasn't changed fully simple recombination of positions\n * Otherwise rebuild viewport items\n */\nexport function getUpdatedItemsByPosition<T extends ItemsToUpdate>(\n  pos: number, // coordinate\n  items: T,\n  realCount: number,\n  virtualSize: number,\n  dimension: DimensionDataViewport\n): ItemsToUpdate {\n  const activeItem: RevoGrid.PositionItem = getItemByPosition(dimension, pos);\n  const firstItem: RevoGrid.PositionItem = getFirstItem(items);\n  let toUpdate: ItemsToUpdate;\n  // do simple position recombination if items already present in viewport\n  if (firstItem) {\n    let changedOffsetStart = activeItem.itemIndex - (firstItem.itemIndex || 0);\n    // if item changed\n    if (changedOffsetStart) {\n      // simple recombination\n      toUpdate = recombineByOffset(Math.abs(changedOffsetStart), {\n        positiveDirection: changedOffsetStart > -1,\n        ...dimension,\n        ...items,\n      });\n    }\n  }\n\n  const maxSizeVirtualSize = getMaxVirtualSize(virtualSize, dimension.realSize, activeItem);\n  // if partial recombination add items if revo-viewport has some space left\n  if (toUpdate) {\n    const extra = addMissingItems(activeItem, realCount, maxSizeVirtualSize, toUpdate, dimension);\n    if (extra.length) {\n      updateMissingAndRange(toUpdate.items, extra, toUpdate);\n    }\n  }\n\n  // new collection if no items after replacement full replacement\n  if (!toUpdate) {\n    const items = getItems({\n      firstItemStart: activeItem.start,\n      firstItemIndex: activeItem.itemIndex,\n      origSize: dimension.originItemSize,\n      maxSize: maxSizeVirtualSize,\n      maxCount: realCount,\n      sizes: dimension.sizes,\n    });\n\n    // range now comes from 0 to length - 1\n    toUpdate = {\n      items,\n      start: 0,\n      end: items.length - 1,\n    };\n  }\n  return toUpdate;\n}\n\n// virtual size can differ based on scroll position if some big items are present\n// scroll can be in the middle of item and virtual size will be larger\n// so we need to exclude this part from virtual size hence it's already passed\nfunction getMaxVirtualSize(virtualSize: number, realSize: number, activeItem: RevoGrid.PositionItem) {\n  return Math.min(virtualSize + (activeItem.end - activeItem.start), realSize)\n}\n\nexport function updateMissingAndRange(\n  items: RevoGrid.VirtualPositionItem[],\n  missing: RevoGrid.VirtualPositionItem[],\n  range: RevoGrid.Range\n) {\n  items.splice(range.end + 1, 0, ...missing);\n  // update range if start larger after recombination\n  if (range.start >= range.end && !(range.start === range.end && range.start === 0)) {\n    range.start += missing.length;\n  }\n  range.end += missing.length;\n}\n\n/**\n * If partial replacement\n * this function adds items if viewport has some space left\n */\nexport function addMissingItems<T extends ItemsToUpdate>(\n  firstItem: RevoGrid.PositionItem,\n  realCount: number,\n  virtualSize: number,\n  existingCollection: T,\n  dimension: Pick<RevoGrid.DimensionSettingsState, 'sizes' | 'originItemSize'>,\n): RevoGrid.VirtualPositionItem[] {\n  const lastItem: RevoGrid.VirtualPositionItem = getLastItem(existingCollection);\n  const items = getItems({\n    sizes: dimension.sizes,\n    firstItemStart: lastItem.end,\n    firstItemIndex: lastItem.itemIndex + 1,\n    origSize: dimension.originItemSize,\n    maxSize: virtualSize - (lastItem.end - firstItem.start),\n    maxCount: realCount,\n  });\n  return items;\n}\n\n/**\n * Get wiewport items parameters\n * caching position and calculating items count in viewport\n */\nexport function getItems(\n  opt: {\n    firstItemIndex: number;\n    firstItemStart: number;\n    origSize: number;\n    maxSize: number; // virtual size\n    maxCount: number; // real item count, where the last item\n    sizes?: RevoGrid.ViewSettingSizeProp;\n  },\n  currentSize = 0,\n) {\n  const items: RevoGrid.VirtualPositionItem[] = [];\n\n  let index = opt.firstItemIndex;\n  let size = currentSize;\n\n  // max size or max count\n  while (size <= opt.maxSize && index < opt.maxCount) {\n    const newSize = getItemSize(index, opt.sizes, opt.origSize);\n    items.push({\n      start: opt.firstItemStart + size,\n      end: opt.firstItemStart + size + newSize,\n      itemIndex: index,\n      size: newSize,\n    });\n    size += newSize;\n    index++;\n  }\n  return items;\n}\n\n/**\n * Do batch items recombination\n * If items not overlapped with existing viewport returns null\n */\ntype RecombindDimensionData = Pick<RevoGrid.DimensionSettingsState, 'sizes' | 'realSize' | 'originItemSize'>;\ntype RecombineOffsetData = {\n  positiveDirection: boolean;\n} & ItemsToUpdate & RecombindDimensionData;\nexport function recombineByOffset(\n  offset: number,\n  data: RecombineOffsetData\n): ItemsToUpdate | null {\n  const newItems = [...data.items];\n  const itemsCount = newItems.length;\n  let newRange = {\n    start: data.start,\n    end: data.end,\n  };\n\n  // if offset out of revo-viewport, makes sense whole redraw\n  if (offset > itemsCount) {\n    return null;\n  }\n\n  // is direction of scroll positive\n  if (data.positiveDirection) {\n    // push item to the end\n    let lastItem: RevoGrid.VirtualPositionItem = getLastItem(data);\n\n    let i: number = newRange.start;\n    const length = i + offset;\n    for (; i < length; i++) {\n      const newIndex: number = lastItem.itemIndex + 1;\n      const size: number = getItemSize(newIndex, data.sizes, data.originItemSize);\n\n      // if item overlapped limit break a loop\n      if (lastItem.end + size > data.realSize) {\n        break;\n      }\n\n      // new item index to recombine\n      let newEnd = i % itemsCount;\n\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newEnd]) {\n        throw new Error('incorrect index');\n      }\n\n      // do recombination\n      newItems[newEnd] = lastItem = {\n        start: lastItem.end,\n        end: lastItem.end + size,\n        itemIndex: newIndex,\n        size: size,\n      };\n      // update range\n      newRange.start++;\n      newRange.end = newEnd;\n    }\n\n    // direction is negative\n  } else {\n    // push item to the start\n    let firstItem: RevoGrid.VirtualPositionItem = getFirstItem(data);\n\n    const end = newRange.end;\n    for (let i = 0; i < offset; i++) {\n      const newIndex: number = firstItem.itemIndex - 1;\n      const size: number = getItemSize(newIndex, data.sizes, data.originItemSize);\n\n      // new item index to recombine\n      let newStart = end - i;\n      newStart = (newStart < 0 ? itemsCount + newStart : newStart) % itemsCount;\n\n      // item should always present, we do not create new item, we recombine them\n      if (!newItems[newStart]) {\n        throw new Error('incorrect index');\n      }\n\n      // do recombination\n      newItems[newStart] = firstItem = {\n        start: firstItem.start - size,\n        end: firstItem.start,\n        itemIndex: newIndex,\n        size: size,\n      };\n      // update range\n      newRange.start = newStart;\n      newRange.end--;\n    }\n  }\n  const range = {\n    start: (newRange.start < 0 ? itemsCount + newRange.start : newRange.start) % itemsCount,\n    end: (newRange.end < 0 ? itemsCount + newRange.end : newRange.end) % itemsCount,\n  };\n  return {\n    items: newItems,\n    ...range,\n  };\n}\n\nfunction getItemSize(index: number, sizes?: RevoGrid.ViewSettingSizeProp, origSize: number = 0): number {\n  if (sizes && sizes[index]) {\n    return sizes[index];\n  }\n  return origSize;\n}\n\n/**\n * Verify if position is in range of the PositionItem, start and end are included\n */\nexport function isActiveRange(\n  pos: number,\n  realSize: number,\n  first?: RevoGrid.PositionItem,\n  last?: RevoGrid.PositionItem\n): boolean {\n  if (!first || !last) {\n    return false;\n  }\n  // if position is in range of first item\n  // or position is after first item and last item is the last item in real size\n  return pos >= first.start && pos <= first.end ||\n    pos > first.end && last.end === realSize;\n}\n\nexport function isActiveRangeOutsideLastItem(pos: number, virtualSize: number, firstItem?: RevoGrid.PositionItem, lastItem?: RevoGrid.PositionItem) {\n  // if no first item, means no items in viewport\n  if (!firstItem) {\n    return false;\n  }\n  return virtualSize + pos > lastItem?.end\n}\n\nexport function getFirstItem(s: ItemsToUpdate): RevoGrid.VirtualPositionItem | undefined {\n  return s.items[s.start];\n}\n\nexport function getLastItem(s: ItemsToUpdate): RevoGrid.VirtualPositionItem {\n  return s.items[s.end];\n}\n\n/**\n * Set items sizes from start index to end\n * @param vpItems \n * @param start \n * @param size \n * @param lastCoordinate \n * @returns \n */\nexport function setItemSizes(\n  vpItems: RevoGrid.VirtualPositionItem[],\n  initialIndex: number,\n  size: number,\n  lastCoordinate: number\n) {\n  const items = [...vpItems];\n  const count = items.length;\n\n  let pos = lastCoordinate;\n  let i = 0;\n  let start = initialIndex;\n\n  // viewport not inited\n  if (!count) {\n    return [];\n  }\n   // loop through array from initial item after recombination\n   while (i < count) {\n    const item = items[start];\n    item.start = pos;\n    item.size = size;\n    item.end = item.start + size;\n    pos = item.end;\n    // loop by start index\n    start++;\n    i++;\n\n    // if start index out of array, reset it\n    if (start === count) {\n      start = 0;\n    }\n  }\n  return items;\n}\n","/**\n * Store is responsible for visible\n * Viewport information for each dimension\n * Redraw items during scrolling\n */\n\nimport { createStore } from '@stencil/store';\n\nimport {\n  addMissingItems,\n  DimensionDataViewport,\n  getFirstItem,\n  getLastItem,\n  getUpdatedItemsByPosition,\n  isActiveRange,\n  setItemSizes,\n  updateMissingAndRange,\n  isActiveRangeOutsideLastItem,\n} from './viewport.helpers';\n\nimport { setStore } from '../../utils/store.utils';\nimport { Observable, RevoGrid } from '../../interfaces';\n\nfunction initialState(): RevoGrid.ViewportState {\n  return {\n    // virtual item information per rendered item\n    items: [],\n    // virtual dom item order to render\n    start: 0,\n\n    end: 0,\n\n    // size of viewport in px\n    virtualSize: 0,\n\n    // total number of items\n    realCount: 0,\n  };\n}\n\nexport default class ViewportStore {\n  readonly store: Observable<RevoGrid.ViewportState>;\n  // last coordinate for store position restore\n  private lastKnownScroll = 0;\n  get lastCoordinate() {\n    return this.lastKnownScroll;\n  }\n  private set lastCoordinate(value: number) {\n    this.lastKnownScroll = value;\n  }\n  constructor(readonly type: RevoGrid.MultiDimensionType) {\n    this.store = createStore(initialState());\n    this.store.onChange('realCount', () => this.clearItems());\n    // drop items on virtual size change, require a new item set\n    this.store.onChange('virtualSize', () => this.setViewport({ items: [] }));\n  }\n\n  /**\n   * Render viewport based on coordinate\n   * It's the main method for draw\n   */\n  setViewPortCoordinate(position: number, dimension: DimensionDataViewport) {\n    const viewportSize = this.store.get('virtualSize');\n    // no visible data to calculate\n    if (!viewportSize) {\n      return;\n    }\n\n    const frameOffset = 1;\n    const singleOffsetInPx = dimension.originItemSize * frameOffset;\n    // add offset to virtual size from both sides\n    const outsize = singleOffsetInPx * 2;\n    // math virtual size is based on visible area + 2 items outside of visible area\n    const virtualSize = viewportSize + outsize;\n\n    // expected no scroll if real size less than virtual size, position is 0\n    let maxCoordinate = 0;\n    // if there is nodes outside of viewport, max coordinate has to be adjusted\n    if (dimension.realSize > viewportSize) {\n      // max coordinate is real size minus virtual/rendered space\n      maxCoordinate = dimension.realSize - viewportSize - singleOffsetInPx;\n    }\n\n    let pos = position;\n    // limit position to max and min coordinates\n    if (pos < 0) {\n      pos = 0;\n    } else if (pos > maxCoordinate) {\n      pos = maxCoordinate;\n    }\n\n    // store last coordinate for further restore on redraw\n    this.lastCoordinate = pos;\n\n    // actual position is less than first item start based on offset\n    pos -= singleOffsetInPx;\n    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;\n\n    const allItems = this.getItems();\n    const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n    const lastItem: RevoGrid.VirtualPositionItem | undefined = getLastItem(allItems);\n\n\n    let toUpdate: Partial<RevoGrid.ViewportState> = {};\n    // left position changed\n    // verify if new position is in range of previously rendered first item\n    if (!isActiveRange(pos, dimension.realSize, firstItem, lastItem)) {\n      toUpdate = {\n        ...toUpdate,\n        ...getUpdatedItemsByPosition(pos, allItems, this.store.get('realCount'), virtualSize, dimension),\n      };\n      this.setViewport({ ...toUpdate });\n    // verify is render area is outside of last item\n    } else if (isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem)) {\n      // check is any item missing for full fill content\n      const missing = addMissingItems(firstItem, this.store.get('realCount'), virtualSize + pos - firstItem.start, allItems, dimension);\n\n      // update missing items\n      if (missing.length) {\n        const items = [...this.store.get('items')];\n        const range = {\n          start: this.store.get('start'),\n          end: this.store.get('end'),\n        };\n        updateMissingAndRange(items, missing, range);\n        toUpdate = {\n          ...toUpdate,\n          items: [...items],\n          ...range,\n        };\n        this.setViewport({ ...toUpdate });\n      }\n    }\n  }\n\n  /**\n   * Update viewport sizes for existing items\n   * This method is generating new item positions based on custom sizes and original sizes\n   * @param sizes - custom sizes for each item\n   * @param dropToOriginalSize - drop to original size if requested\n   */\n  setViewPortDimensionSizes(sizes: RevoGrid.ViewSettingSizeProp, dropToOriginalSize?: number) {\n    let items = [...this.store.get('items')];\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    let changedCoordinate = 0;\n    let i = 0;\n    let start = this.store.get('start');\n\n    // drop to original size if requested\n    if (dropToOriginalSize) {\n      const allItems = this.getItems();\n      const firstItem: RevoGrid.VirtualPositionItem | undefined = getFirstItem(allItems);\n      items = setItemSizes(items, start, dropToOriginalSize, firstItem.start);\n    }\n\n    // loop through array from initial item after recombination\n    // if size change present, change position for all items after\n    while (i < count) {\n      const item = items[start];\n      // change pos if size change present before\n      if (changedCoordinate) {\n        item.start += changedCoordinate;\n        item.end += changedCoordinate;\n      }\n      // check if size change present\n      const size: number | undefined = sizes[item.itemIndex];\n      // size found\n      if (size) {\n        const changedSize = size - item.size;\n        changedCoordinate += changedSize;\n        item.size = size;\n        item.end = item.start + size;\n        // size lost\n      }\n\n      // loop by start index\n      start++;\n      i++;\n      // if start index out of array, reset it\n      if (start === count) {\n        start = 0;\n      }\n    }\n\n    this.setViewport({ items: [...items] });\n  }\n\n  /**\n   * Set sizes for existing items\n   */\n  setOriginalSizes(size: number) {\n    const items = this.store.get('items');\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    setStore(this.store, {\n      items: setItemSizes(items, this.store.get('start'), size, this.lastCoordinate),\n    });\n  }\n\n  getItems(): Pick<RevoGrid.ViewportStateItems, 'items' | 'start' | 'end'> {\n    return {\n      items: this.store.get('items'),\n      start: this.store.get('start'),\n      end: this.store.get('end'),\n    };\n  }\n\n  setViewport(data: Partial<RevoGrid.ViewportState>) {\n    setStore(this.store, data);\n  }\n\n  clearItems() {\n    this.store.set('items', []);\n  }\n}\n","import { RevoGrid } from '../interfaces';\n\nconst LETTER_BLOCK_SIZE = 10;\nexport const calculateRowHeaderSize = (itemsLength: number, rowHeaderColumn?: RevoGrid.RowHeaders) => {\n  return rowHeaderColumn?.size || (itemsLength.toString().length + 1) * LETTER_BLOCK_SIZE;\n};\n","import { VNode } from '@stencil/core';\nimport { RevoGrid } from '../../interfaces';\n\ntype HeaderRender = {\n  (start: number): (h: RevoGrid.HyperFunc<VNode>, e: { rowIndex: number }) => number;\n};\nexport const RowHeaderRender: HeaderRender = s => (__, { rowIndex: i }) => s + i;\n","import { h, Host } from '@stencil/core';\nimport { Component, Prop, Event, EventEmitter } from '@stencil/core';\nimport { RevoGrid } from '../../interfaces';\nimport DataStore from '../../store/dataSource/data.store';\nimport ViewportStore from '../../store/viewPort/viewport.store';\nimport { ROW_HEADER_TYPE, UUID } from '../../utils/consts';\nimport { ElementScroll } from '../revoGrid/viewport.scrolling.service';\nimport { ViewportData } from '../revoGrid/viewport.interfaces';\nimport { RowHeaderRender } from './row-header-render';\nimport { calculateRowHeaderSize } from '../../utils/row-header-utils';\nimport { HEADER_SLOT } from '../revoGrid/viewport.helpers';\nimport { JSX } from '../..';\n\n/**\n * Row headers component\n * Visible on the left side of the table\n */\n\n@Component({ tag: 'revogr-row-headers' })\nexport class RevogrRowHeaders {\n  @Prop() height: number;\n\n  @Prop() dataPorts: ViewportData[];\n  @Prop() headerProp: Record<string, any>;\n  @Prop() uiid: string;\n  @Prop() rowClass: string;\n\n  @Prop() resize: boolean;\n  @Prop() rowHeaderColumn: RevoGrid.RowHeaders;\n  /** Additional data to pass to renderer */\n  @Prop() additionalData: any;\n\n  @Event({ bubbles: false })\n  scrollViewport: EventEmitter<RevoGrid.ViewPortScrollEvent>;\n  @Event({ bubbles: false }) elementToScroll: EventEmitter<ElementScroll>;\n\n  render() {\n    const dataViews: HTMLElement[] = [];\n    const viewport = new ViewportStore('colPinStart');\n\n    /** render viewports rows */\n    let totalLength = 1;\n    for (let data of this.dataPorts) {\n      const itemCount = data.dataStore.get('items').length;\n      // initiate row data\n      const dataStore = new DataStore<\n        RevoGrid.DataType,\n        RevoGrid.DimensionRows\n      >(data.type);\n      dataStore.updateData(data.dataStore.get('source'));\n      // initiate column data\n      const colData = new DataStore<\n        RevoGrid.ColumnRegular,\n        RevoGrid.DimensionCols\n      >('colPinStart');\n      const column: RevoGrid.ColumnRegular = {\n        cellTemplate: RowHeaderRender(totalLength),\n        ...this.rowHeaderColumn,\n      };\n      colData.updateData([column]);\n\n      const viewData = {\n        ...data,\n        rowClass: this.rowClass,\n        dataStore: dataStore.store,\n        colData: colData.store,\n        viewportCol: viewport.store,\n        readonly: true,\n        range: false,\n      };\n      dataViews.push(\n        <revogr-data {...viewData}></revogr-data>,\n      );\n      totalLength += itemCount;\n    }\n\n    const colSize = calculateRowHeaderSize(totalLength, this.rowHeaderColumn);\n    viewport.setViewport({\n      realCount: 1,\n      virtualSize: 0,\n      items: [\n        {\n          size: colSize,\n          start: 0,\n          end: colSize,\n          itemIndex: 0,\n        },\n      ],\n    });\n\n    const parent = `${this.uiid}-rowHeaders`;\n    const viewportScroll = {\n      [UUID]: parent,\n      contentHeight: this.height,\n      contentWidth: 0,\n      style: { minWidth: `${colSize}px` },\n      ref: (el: ElementScroll) => this.elementToScroll.emit(el),\n      onScrollViewport: (e: CustomEvent) => this.scrollViewport.emit(e.detail),\n    };\n    const viewportHeader: JSX.RevogrHeader & { slot: string } = {\n      ...this.headerProp,\n      colData:\n        typeof this.rowHeaderColumn === 'object' ? [this.rowHeaderColumn] : [],\n      viewportCol: viewport.store,\n      canResize: false,\n      type: ROW_HEADER_TYPE,\n      parent,\n      slot: HEADER_SLOT,\n    };\n    return (\n      <Host class={{ [ROW_HEADER_TYPE]: true }} key={ROW_HEADER_TYPE}>\n        <revogr-viewport-scroll {...viewportScroll} row-header={true}>\n          <revogr-header {...viewportHeader} />\n          {dataViews}\n        </revogr-viewport-scroll>\n      </Host>\n    );\n  }\n}\n"],"version":3}