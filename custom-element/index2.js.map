{"file":"index2.js","mappings":";;;;;;AAiFA;SACgB,iBAAiB,CAAC,GAAa;;EAE7C,MAAM,KAAK,GAAgB,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;EACpD,MAAM,MAAM,GAAgC,KAAK,CAAC,KAAoC,CAAC;EACvF,MAAM,CAAC,UAAU,GAAG,QAAQ,CAAC;EAC7B,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;EAC3B,MAAM,CAAC,eAAe,GAAG,WAAW,CAAC;EACrC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;;EAG5B,MAAM,KAAK,GAAmB,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;EACvD,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;;EAGzB,MAAM,cAAc,GAAW,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;;EAGrE,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;EAEpC,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;;;;;;;;;;;SAYgB,UAAU,CAAC,KAAa,EAAE,IAAsB,EAAE,EAAoB;EACpF,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAC7E,CAAC;AAED;;;AAGO,eAAe,OAAO,CAAC,KAAK,GAAG,CAAC;EACrC,MAAM,IAAI,OAAO,CAAC,CAAC,CAAoB;IACrC,UAAU,CAAC,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;GAC9B,CAAC,CAAC;AACL;;;;","names":[],"sources":["src/utils/index.ts"],"sourcesContent":["export * from '../store/dimension/dimension.helpers';\n\n\ninterface CSSStyleDeclarationExtended extends CSSStyleDeclaration {\n  msOverflowStyle: string;\n}\n\n/* Generate range on size\n */\nexport function range(size: number, startAt: number = 0): number[] {\n  const res: number[] = [];\n  const end = startAt + size;\n  for (let i = startAt; i < end; i++) {\n    res.push(i);\n  }\n  return res;\n}\n\n/* Find index position in array */\nexport function findPositionInArray<T>(this: T[], el: T, compareFn: (el: T, el2: T) => number): number {\n  return (function (arr): number {\n    let m: number = 0;\n    let n: number = arr.length - 1;\n\n    while (m <= n) {\n      const k: number = (n + m) >> 1;\n      const cmp: number = compareFn(el, arr[k]);\n\n      if (cmp > 0) {\n        m = k + 1;\n      } else if (cmp < 0) {\n        n = k - 1;\n      } else {\n        return k;\n      }\n    }\n\n    return -m - 1;\n  })(this);\n}\n\n/**\n * Sorted push\n */\nexport function pushSorted<T>(arr: T[], el: T, fn: (el: T, el2: T) => number): T[] {\n  arr.splice(findPositionInArray.bind(arr)(el, fn), 0, el);\n  return arr;\n}\n\n// (arr1[index1] < arr2[index2])\nfunction simpleCompare<T>(el1: T, el2: T): boolean {\n  return el1 < el2;\n}\n\n/**\n * Merge sorted array helper function\n */\nexport function mergeSortedArray<T>(arr1: T[], arr2: T[], compareFn: (el: T, el2: T) => boolean = simpleCompare): T[] {\n  const merged: T[] = [];\n  let index1: number = 0;\n  let index2: number = 0;\n  let current: number = 0;\n\n  while (current < arr1.length + arr2.length) {\n    let isArr1Depleted = index1 >= arr1.length;\n    let isArr2Depleted = index2 >= arr2.length;\n\n    if (!isArr1Depleted && (isArr2Depleted || compareFn(arr1[index1], arr2[index2]))) {\n      merged[current] = arr1[index1];\n      index1++;\n    } else {\n      merged[current] = arr2[index2];\n      index2++;\n    }\n\n    current++;\n  }\n\n  return merged;\n}\n\n/* Calculate system scrollbar width */\nexport function getScrollbarWidth(doc: Document): number {\n  // Creating invisible container\n  const outer: HTMLElement = doc.createElement('div');\n  const styles: CSSStyleDeclarationExtended = outer.style as CSSStyleDeclarationExtended;\n  styles.visibility = 'hidden';\n  styles.overflow = 'scroll'; // forcing scrollbar to appear\n  styles.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\n  doc.body.appendChild(outer);\n\n  // Creating inner element and placing it in the container\n  const inner: HTMLDivElement = doc.createElement('div');\n  outer.appendChild(inner);\n\n  // Calculating difference between container's full width and the child width\n  const scrollbarWidth: number = outer.offsetWidth - inner.offsetWidth;\n\n  // Removing temporary elements from the DOM\n  outer.parentNode.removeChild(outer);\n\n  return scrollbarWidth;\n}\n\n/* Scale a value between 2 ranges\n *\n * Sample:\n * // 55 from a 0-100 range to a 0-1000 range (Ranges don't have to be positive)\n * const n = scaleValue(55, [0,100], [0,1000]);\n *\n * Ranges of two values\n * @from\n * @to\n *\n * ~~ return value does the equivalent of Math.floor but faster.\n */\nexport function scaleValue(value: number, from: [number, number], to: [number, number]): number {\n  return ((to[1] - to[0]) * (value - from[0])) / (from[1] - from[0]) + to[0];\n}\n\n/**\n * Async timeout\n */\nexport async function timeout(delay = 0): Promise<void> {\n  await new Promise((r: (v?: any) => void) => {\n    setTimeout(() => r(), delay);\n  });\n}\n\n/**\n * Type script mixins\n */\nexport function applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));\n    });\n  });\n}\n"],"version":3}