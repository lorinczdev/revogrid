{"file":"revogr-temp-range2.js","mappings":";;;;;;;;AAAA,MAAM,uBAAuB,GAAG,w+UAAw+U;;MCa3/U,WAAW;;;;IAsBL,aAAQ,GAAGA,eAAQ,CAAC,CAAC,CAAc,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;;;;;EAExE,QAAQ,CAAC,CAAc;IAC7B,CAAC,aAAD,CAAC,uBAAD,CAAC,CAAE,cAAc,CAAC;MAChB,KAAK,EAAE,SAAS;MAChB,MAAM,EAAE,SAAS;KAClB,CAAC,CAAC;GACJ;EAED,kBAAkB;IAChB,IAAI,IAAI,CAAC,EAAE,EAAE;MACX,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACxB;GACF;EAED,MAAM;IACJ,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAClD,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;IACtD,IAAI,CAAC,IAAI,EAAE;MACT,OAAO;KACR;IACD,IAAI,UAAU,GAAG,QAAQ,CAAC;IAC1B,IAAI,UAAU,GAAG,OAAO,CAAC;IACzB,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAC9B,IAAI,CAAC,KAAK,EAAE;MACV,OAAO;KACR;IACD,IAAI,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;MACpB,UAAU,GAAG,KAAK,CAAC;KACpB;IACD,IAAI,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;MACpB,UAAU,GAAG,MAAM,CAAC;KACrB;IACD,MAAM,cAAc,GAAG,GAAG,UAAU,IAAI,UAAU,EAAE,CAAC;IACrD,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IACjF,QACE,EAAC,IAAI,IACH,KAAK,EAAE;QACL,CAAC,sBAAsB,GAAG,IAAI;QAC9B,CAAC,IAAI,IAAI,EAAE,GAAG,IAAI;OACnB,EACD,KAAK,EAAE,KAAK,EACZ,MAAM,EAAE,KAAK,IAEb,WAAK,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,CAAC,CAAc,MAAM,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAI,CACjE,EACP;GACH;EAEO,QAAQ;IACd,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,KAAK,EAAE;MACT,OAAO,KAAK,CAAC;KACd;IACD,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,CAAC,KAAK,EAAE;MACV,OAAO,IAAI,CAAC;KACb;IACD,uCACK,KAAK,KACR,EAAE,EAAE,KAAK,CAAC,CAAC,EACX,EAAE,EAAE,KAAK,CAAC,CAAC,IACX;GACH;;;;;;;;;;;;;;;;;;;;;;;","names":["throttle"],"sources":["src/components/selectionTempRange/revogr-temp-range-style.scss?tag=revogr-temp-range","src/components/selectionTempRange/revogr-temp-range.tsx"],"sourcesContent":[".temp-bg-range {\n  display: block !important;\n  position: absolute;\n  pointer-events: none;\n  z-index: 9;\n  border: 1px solid rgb(255, 94, 0);\n  box-sizing: border-box;\n\n  &.Selection {\n    border: 1px dashed gray;\n  }\n\n  > div {\n    width: 1px;\n    height: 1px;\n    position: absolute;\n\n    &.top {\n      top: -1px;\n    }\n\n    &.bottom {\n      bottom: -1px;\n    }\n\n    &.left {\n      left: -1px;\n    }\n\n    &.right {\n      right: -1px;\n    }\n  }\n}\n","import { Component, Prop, h, Host } from '@stencil/core';\nimport { throttle } from 'lodash';\nimport { Observable, RevoGrid, Selection } from '../../interfaces';\nimport { TMP_SELECTION_BG_CLASS } from '../../utils/consts';\nimport { getElStyle } from '../overlay/selection.utils';\n\n/**\n * Temporary range selection\n */\n@Component({\n  tag: 'revogr-temp-range',\n  styleUrl: 'revogr-temp-range-style.scss',\n})\nexport class RevogrFocus {\n  el: HTMLElement;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Dynamic stores\n  //\n  // --------------------------------------------------------------------------\n\n  /**\n   * Selection store, shows current selection and focus\n   */\n  @Prop() selectionStore: Observable<Selection.SelectionStoreState>;\n\n  /**\n   * Dimension row store\n   */\n  @Prop() dimensionRow: Observable<RevoGrid.DimensionSettingsState>;\n  /**\n   * Dimension column store\n   */\n  @Prop() dimensionCol: Observable<RevoGrid.DimensionSettingsState>;\n  private readonly onChange = throttle((e: HTMLElement) => this.doChange(e), 300);\n\n  private doChange(e: HTMLElement): void {\n    e?.scrollIntoView({\n      block: 'nearest',\n      inline: 'nearest',\n    });\n  }\n\n  componentDidRender(): void {\n    if (this.el) {\n      this.onChange(this.el);\n    }\n  }\n\n  render() {\n    const data = this.selectionStore.get('tempRange');\n    const type = this.selectionStore.get('tempRangeType');\n    if (!data) {\n      return;\n    }\n    let directionY = 'bottom';\n    let derectionX = 'right';\n    const range = this.getRange();\n    if (!range) {\n      return;\n    }\n    if (data.y < range.y) {\n      directionY = 'top';\n    }\n    if (data.x < range.x) {\n      derectionX = 'left';\n    }\n    const directionClass = `${derectionX} ${directionY}`;\n    const style = getElStyle(data, this.dimensionRow.state, this.dimensionCol.state);\n    return (\n      <Host\n        class={{\n          [TMP_SELECTION_BG_CLASS]: true,\n          [type || '']: true,\n        }}\n        style={style}\n        hidden={false}\n      >\n        <div class={directionClass} ref={(e: HTMLElement) => (this.el = e)} />\n      </Host>\n    );\n  }\n\n  private getRange(): Selection.RangeArea | null {\n    const range = this.selectionStore.get('range');\n    if (range) {\n      return range;\n    }\n    const focus = this.selectionStore.get('focus');\n    if (!focus) {\n      return null;\n    }\n    return {\n      ...focus,\n      x1: focus.x,\n      y1: focus.y,\n    };\n  }\n}\n"],"version":3}